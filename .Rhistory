raw_table<-read.table("profiles.csv",header=FALSE,sep=",")
library(ggplot2)		#
library(reshape2)#
library(matrixStats)#
library(scales)#
library(grid)#
library(RColorBrewer)
cellProfiles <- function(data=NULL,position="center",align="native",reverse=FALSE,contrast="native",range=c(0.02,0.98)){#
#============================#
#USER GUIDE#
##
#Command line variables#
# Change the behavior of this function by defining these variables when calling it#
##
# 		eg: profileResults <- cellProfiles(data=dtable,align="orient",reverse=TRUE,contrast="normx")#
#		The above command would use the data "dtable" to produce a graph with:#
#			1) cells automatically aligned with the brightest sides [orient]#
#			2) on the *left* [reverse]#
#			3) while applying the normalize function (maximum ratio enforced via truncation) [normx]#
##
# data-handling options#
#  position = "center" or "left"#
#		[DEFAULT]->	center:	 plot with midcells aligned at point zero#
#					left:	plot with left side of cells aligned at zero#
##
#  align 	= "native", "orient", "random", "reuse"#
#		[DEFAULT]->	native:	profiles maintain original alignment#
#					orient:	automatically aligns the cell profiles so that the brightest points are on the same side#
#					random:	cells are randomly flipped#
#					reuse:	apply the last graphed orientations to the current graph#
##
#  reverse	= FALSE or TRUE#
#		[DEFAULT]->	FALSE:	no change in orientation#
#					TRUE:	plot profiles in reverse orientation (can be combined with, eg, align="reuse")#
#					#
# contrast adjustments for graphs	#
#  contrast = "native", "norm", "max"#
#		[DEFAULT]->	native:	profiles maintain original fluorescence intensities#
#					norm:  	divides each profile by its mean value#
#					max:	maximizes contrast #
##
#  range	= c(min,max)	This vector defines the lower and upper percentile boundaries of the color scale#
#		[DEFAULT]->	c(0.02,0.98)		treat these limits like changing the min/max displayed constrast in ImageJ etc#
##
#Exported variables#
# these variables are accessible from the script results. #
##
# 		eg, if you run: profileResults <- cellProfiles(data=dtable)#
# 		then the formatted final table is accessible at profileResults$form_dtable. #
# 		write the table to a new csv file using: #
#				write.csv(as.matrix(profileResults$form_dtable),file="cellprofiles wide format.csv")#
##
# or_dtable		long data table for ggplot#
# lim_or_dtable	long data table for ggplot, with values truncated as defined by the range setting#
# data			input data#
# form_dtable	wide-formatted table for human eyes#
# prop_dtable	long data table, where cell length is converted to fraction of cell length#
# ncol			number of cells measured#
# nrow			length of original data table#
# max			max fluorescence #
# min			min fluorescence#
# med			median fluorescence#
# mid			midpoint between min & max fluorescence#
# maxlength		longest cell length#
##
#END USER GUIDE#
#============================#
	t0<-proc.time()#
#
	#set up a few variables#
	if (local(exists("cellProfilesFunctionEnvironment.env"),envir=.GlobalEnv) == FALSE){local(cellProfilesFunctionEnvironment.env<-new.env(),envir=.GlobalEnv)}#
	if (!(is.vector(range)) || (!(length(range)==2)) || !(range[1]>=0 && range[2]<=1) || !(range[1]<range[2])){#
		cat("ERROR: Range must be between 0 and 1, in the format: c(min,max).");return(NULL)#
	}#
	if (position=="left"){adj_tick<-5} else {adj_tick<-6}#
	cmin<-range[1]#
	cmax<-range[2]#
	ncol<-ncol(data)/2#
	nrow<-nrow(data)#
	dlength<-data[seq(1,ncol*2,by=2)]#
	profile<-data[seq(2,ncol*2,by=2)]#
	maxlength<-ceiling(max(dlength,na.rm=TRUE))#
	wtmeanleft<-log((50:5)/5)/log(10)#
	wtmeanright<-log((5:50)/5)/log(10)#
	#sets up profile fliplist, or preserves prior orientations & disables inappropriate flags#
	if (align == "reuse"){#
		if ((local(exists("fliplist"), envir=cellProfilesFunctionEnvironment.env) != TRUE) || !(ncol == length(local(fliplist, envir=cellProfilesFunctionEnvironment.env)))){#
			cat("ERROR: Use of the align=\"reuse\" option requires prior evaluation of a dataset with the same number of cells... otherwise there is nothing to \"reuse\".")#
			return(NULL)#
		}#
		if (reverse == TRUE){#
			local(fliplist<-(fliplist-1)/-1, envir=cellProfilesFunctionEnvironment.env)#
		}#
	} else {#
		cellProfilesFunctionEnvironment.env$fliplist<-rep(1,ncol)#
		if (align == "random"){#
			cellProfilesFunctionEnvironment.env$fliplist[sample(ncol,ncol/2)]<-0#
		}#
	}#
	#perform contrast adjustments and aligns or randomizes data as set in the options above#
	cat("Calculating: \n ..")#
	tick<-txtProgressBar(min=1,max=ncol*adj_tick,style=3)#
	tmp_profile<-profile#
	for(ii in 1:ncol){#
		#for orient flag, find out if the top half of the column is brighter than the bottom half#
		#if not, then set fliplist[ii] to 1 so the column will be reversed#
		real_rows<-colCounts(as.matrix(profile[ii]+1),na.rm=TRUE)#
		half_rows<-round(real_rows/2)#
		if ((align == "orient") && mean(profile[1:half_rows,ii]*approx(wtmeanleft,n=half_rows)$y) < mean(profile[(real_rows-half_rows+1):real_rows,ii]*approx(wtmeanright,n=half_rows)$y)){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-0#
		}#
		if ((reverse == TRUE) && (align != "reuse")){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-(cellProfilesFunctionEnvironment.env$fliplist[ii]-1)/-1#
		}#
		#normalize profile data, as appropriate#
		if (contrast == "norm"){#
			col_mean<-mean(as.matrix(profile[ii]),na.rm=TRUE)#
			profile[ii]<-(profile[ii]/col_mean)#
		}#
		#col_min & max are used to adjust contrast when max contrast is called		#
		if (contrast != "max"){#
			col_min<-0#
			col_max<-1#
		}	else {#
			col_min<-min(profile[ii],na.rm=TRUE)	#
			col_max<-max(profile[ii],na.rm=TRUE)-col_min#
		}#
		#save flipped/reversed/contrast adjusted values into tmp_profile, as appropriate #
		if (cellProfilesFunctionEnvironment.env$fliplist[ii]==1) {#
			tmp_profile[c(real_rows:1),ii]<-(profile[c(1:real_rows),ii]-col_min)/(col_max)#
		} else {#
			tmp_profile[c(1:real_rows),ii]<-(profile[c(1:real_rows),ii]-col_min)/(col_max)#
		}#
		setTxtProgressBar(tick,ii)#
	}#
	profile<-tmp_profile	#
	#find the number of real values in each column, then order from lowest to highest#
	#collength<-{}#
	#for(i in 1:ncol){#
	#	collength[i]<-colCounts(as.matrix(profile[i]+1),na.rm=TRUE)#
	#}#
	#setTxtProgressBar(tick,2*ncol)#
	#collength<-order(collength)#
    #find maximum length of each column, and the number of real values in each column#
    #then order cells by measured cell length values#
	cellength<-{}#
	collength<-{}#
	for(i in 1:ncol){#
		cellength[i]<-max(dlength[i],na.rm=TRUE)#
	}#
	for(i in 1:ncol){#
		collength[i]<-colCounts(as.matrix(profile[i]+1),na.rm=TRUE)#
	}#
	setTxtProgressBar(tick,2*ncol)#
	collength<-order(cellength)#
	#setup the y values to stack each profile#
	plotheight<-{}#
	for(i in 1:ncol){#
		temp<-rep(i,nrow)#
		plotheight<-append(plotheight,temp)#
	}#
	setTxtProgressBar(tick,3*ncol)#
	#shifts cells to center (if center = TRUE)#
	if (position == "center"){#
		for(ii in 1:ncol){#
			col_adj<-(max(dlength[ii],na.rm=TRUE)+min(dlength[ii],na.rm=TRUE))/2#
			dlength[ii]<-dlength[ii]-col_adj#
		}#
	}#
	setTxtProgressBar(tick,(adj_tick-2)*ncol)#
	#apply order info from above#
	or_dlength<-melt(dlength[collength],id=NULL)#
	or_profile<-melt(profile[collength],id=NULL)#
	or_dtable<-cbind(or_dlength,plotheight,or_profile[2])#
	names(or_dtable)<- c("cell","x","y","intensity")#
	max<-max(or_dtable["intensity"],na.rm=TRUE)#
	min<-min(or_dtable["intensity"],na.rm=TRUE)#
	med<-median(as.matrix(or_dtable["intensity"]),na.rm=TRUE)#
	mid<-(max-min)/2+min#
	#simple code to breakdown the long data list into something human-readable#
	fodframe<-as.data.frame(or_profile[1:nrow,2])#
	colnames(fodframe)<-or_profile[1,1]#
	for(c in 2:ncol){#
		odframe<-as.data.frame(or_profile[(1:nrow)+(c-1)*nrow,2])#
		colnames(odframe)<-or_profile[(nrow*c),1]#
		fodframe<-cbind(fodframe,odframe)#
	}		#
	setTxtProgressBar(tick,(adj_tick-1)*ncol)#
	fodframe <- round(fodframe*1000)/1000#
	#prepared a list suitable for making x-y scatter plots (x-axis converted to proportion of cell length)#
	or_dlength<-dlength[collength]#
	for(i in 1:ncol){#
		or_dlength[i]<-rescale(or_dlength[i])#
	}#
	setTxtProgressBar(tick,(adj_tick)*ncol)#
	close(tick)#
	or_dlength<-melt(or_dlength,id=NULL)#
	por_dtable<-cbind(or_dlength,plotheight,or_profile[2])#
	names(por_dtable)<- c("cell","x","y","intensity")#
	#eliminate empty rows#
	or_dtable<-or_dtable[!is.na(or_dtable[4])==TRUE,c(1:4)]#
	#create contrast-truncated version#
	lim_or_dtable<-or_dtable	#
	lim_min<-colQuantiles(or_dtable["intensity"],cmin,na.rm=TRUE)#
	lim_max<-colQuantiles(or_dtable["intensity"],cmax,na.rm=TRUE)#
	cmin_count<-length(lim_or_dtable$intensity[lim_or_dtable$intensity<lim_min])#
	cmax_count<-length(lim_or_dtable$intensity[lim_or_dtable$intensity>lim_max])#
	lim_or_dtable[lim_or_dtable["intensity"]<lim_min,"intensity"]<-lim_min#
	lim_or_dtable[lim_or_dtable["intensity"]>lim_max,"intensity"]<-lim_max#
	len_count<-length(lim_or_dtable$intensity)#
	cat(len_count-cmin_count-cmax_count," profile points (",round(1000*(len_count-cmin_count-cmax_count)/len_count)/10,"%) fall in the range between the lower (",round(100*lim_min[[1]])/100,") and upper (",round(100*lim_max[[1]])/100,") contrast limits.\n",sep="")#
	profileResults <- list("or_dtable"=or_dtable, "lim_or_dtable"=lim_or_dtable, "data"=data, "form_dtable"=fodframe, "prop_dtable"=por_dtable, "ncol"=ncol, "nrow"=nrow, "max"=max, "min"=min, "med"=med, "mid"=mid, "maxlength"=maxlength)#
	tf<-proc.time()-t0#
	cat("Calculations on",ncol,"cells complete in",tf[["elapsed"]],"seconds.")#
	return(profileResults)#
}#
#
cellProfileTruncate <- function(data=NULL,adjust){#
#============================#
#USER GUIDE#
##
# This function will remove [adjust] rows from the beginning and end of each cell#
# Use this function to correct when, for eg, wide selection lines collect too much dark background to accurately represent cell poles#
# Another solution to this problem would be to simply plot the graph background to a dark color#
# eg, add to the ggplot2 code: +theme(panel.background = element_rect(fill="#061542"))#
##
# adjust	= a positive integer. Will normally be 1-3 rows or so, depending on how you measured the data originally#
##
#END USER GUIDE#
#============================#
	#various sanity checks before performing the truncation#
	if (!(is.numeric(adjust) && floor(adjust)==adjust) || (adjust<0)){#
		cat("ERROR: adjustment value must be a positive integer.");return(NULL)#
	}#
	if (adjust == 0){#
		return(data)#
	} else if (adjust >= nrow(na.omit(data))/2){#
		cat("ERROR: cannot truncate more rows than exist. Must be",floor(nrow(na.omit(data))/2),"or fewer rows.");return(NULL)#
	} else if (2*adjust/nrow(na.omit(data)) > 0.25){#
		cat("WARNING: truncating ",round(100*2*adjust/nrow(na.omit(data))),"% of the shortest cell. This seems unwise.",sep="")#
	}#
	tmp_dtable<-matrix(NA,nrow(data),ncol(data))#
	#it is pretty easy to lop off the top of the table#
	data<-data[1+adjust:nrow(data),]#
	#however, taking off the bottom rows from each column (of different lengths) is rather more complicated#
	#below is an optimized form of a for loop that would copy, 2 columns at a time, all but the bottom [adjust] row(s)#
	for(i in seq(1,ncol(data),by=2)){#
		tmp_dtable[1:(nrow(as.matrix(data[!is.na(data[,i]),c(i)]))-adjust),c(i,i+1)]<-as.matrix(data[1:(nrow(as.matrix(data[!is.na(data[,i]),c(i)]))-adjust),c(i,i+1)])#
	}#
	return(as.data.frame(tmp_dtable))#
}#
#
library(ggplot2)  	#
library(reshape2)#
library(matrixStats)#
library(scales)#
library(grid)#
library(RColorBrewer)
================================================================#
#INTENSITY HEAT MAPS OVER CELL LENGTH#
#be sure to load the cellProfiles function first!#
#================================================================#
#
#commands for changing to a specific directory & load data tables#
#assumes there is no header... use header=TRUE if there is one#
#setwd("")#
raw_table<-read.table("profiles.csv",header=FALSE,sep=",")#
#
#slightly truncate the poles to remove dark polar bands (artifact from width of profile line)#
dtable<-cellProfileTruncate(data=raw_table,0)#
#
#================================================================#
#the following two graphs are general templates suitable for most data & purposes (in centered, and non-centered versions)#
#================================================================#
#
#CENTERED -norm#
profileResults<-cellProfiles(data=dtable,contrast="norm")#
#
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g#
#NOT CENTERED -norm#
profileResults<-cellProfiles(data=dtable,position="left",contrast="norm")#
#
g2<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="cell length (um)",y="fraction of cell cycle",title="2- position=\"left\"")#
#
dev.new(width=4.86,height=3.4)#
g2#
#================================================================#
#EXAMPLES OF GRAPHING OPTIONS #
#================================================================#
#The following graphs demonstrate the different graphing options available#
#Select from here to the bottom and execute to view them all#
raw_table<-read.table("profiles.csv",header=FALSE,sep=",")#
dtable<-cellProfileTruncate(data=raw_table,0)#
vplayout<-function(x,y) viewport(layout.pos.row=x,layout.pos.col=y)#
#
standard_theme	<-theme_bw(base_size=10)#
standard_labs	<-labs(x="distance from midcell (um)",y="fraction of cell cycle")#
standard_y		<-scale_y_continuous(expand=c(0,0),breaks=seq(0,1,0.25),trans="reverse")#
standard_fill	<-scale_fill_gradientn(colours=rev(brewer.pal(9,"YlGnBu")))#
standard_color	<-scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu")))#
standard_layer	<-function(x1,x2) layer(geom="tile",width=1.01*(x1-x2),size=0.25)#
#
dev.new(width=8,height=3.25)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(2,2, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Position Options", vp=viewport(layout.pos.row=1,layout.pos.col=1:2),gp=gpar(fontsize=16))#
print(g,vp=vplayout(2,1))#
print(g2,vp=vplayout(2,2))#
#
#================================================================#
#3- native#
#================================================================#
profileResults<-cellProfiles(data=dtable)#
#
pt3<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="3- contrast=\"native\"\n")#
#
#================================================================#
#4- max range=c(0,1)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="max",range=c(0,1))#
#
pt4<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + standard_labs+labs(title="4- contrast=\"max\",\n range=c(0,1)")#
#
#================================================================#
#5- norm range=c(0,1)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0,1))#
#
pt5<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="5- contrast=\"norm\",\n range=c(0,1)")#
#
#================================================================#
#6- norm range=c(0.005,0.995)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0.005,0.995))#
#
pt6<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="6- contrast=\"norm\",\n range=c(0.005,0.995)")#
#
#================================================================#
#7- norm range=c(0.02,0.98)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0.02,0.98))#
#
pt7<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="7- contrast=\"norm\",\n range=c(0.02,0.98)")#
#
#================================================================#
#8- norm range=c(0.05,0.95)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0.05,0.95))#
#
pt8<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="8- contrast=\"norm\",\n range=c(0.05,0.95)")#
#
dev.new(width=12,height=6.4)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(3,3, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Contrast Options", vp=viewport(layout.pos.row=1,layout.pos.col=1:3),gp=gpar(fontsize=16))#
print(pt3,vp=vplayout(2,1))#
print(pt5,vp=vplayout(2,2))#
print(pt6,vp=vplayout(2,3))#
print(pt4,vp=vplayout(3,1))#
print(pt7,vp=vplayout(3,2))#
print(pt8,vp=vplayout(3,3))#
#================================================================#
#9- native#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="max")#
#
pt9<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="9- align=\"native\",\n contrast=\"max\"")#
#
#================================================================#
#10- orient#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="orient",contrast="max")#
#
pt10<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="10- align=\"orient\",\n contrast=\"max\"")#
#
#================================================================#
#11- random#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="random",contrast="max")#
#
pt11<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs+labs(title="11- align=\"random\",\n contrast=\"max\"")#
#
#================================================================#
#12- orient / reverse#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="orient",contrast="max",reverse=TRUE)#
#
pt12<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="12- align=\"orient\", reverse=TRUE, \ncontrast=\"max\"")#
#
#================================================================#
#13- reuse / reverse #1#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="reuse",contrast="max",reverse=TRUE)#
#
pt13<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="13- align=\"reuse\", reverse=TRUE, \ncontrast=\"max\"")#
#
#================================================================#
#14- reuse / reverse #2#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="reuse",contrast="max",reverse=TRUE)#
#
pt14<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="14- align=\"reuse\", reverse=TRUE, \ncontrast=\"max\"")#
#
dev.new(width=12,height=6.4)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(3,3, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Alignment Options", vp=viewport(layout.pos.row=1,layout.pos.col=1:3),gp=gpar(fontsize=16))#
print(pt9,vp=vplayout(2,1))#
print(pt10,vp=vplayout(2,2))#
print(pt11,vp=vplayout(2,3))#
print(pt12,vp=vplayout(3,1))#
print(pt13,vp=vplayout(3,2))#
print(pt14,vp=vplayout(3,3))#
#
#================================================================#
#15- line plots of individual profiles \n#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",align="orient")#
#
pt15<-ggplot()+layer(data=profileResults$prop_dtable,mapping=aes(x=x,y=intensity,group=cell),geom="line",alpha=1/sqrt(profileResults$ncol))+theme_bw(base_size=10)+coord_cartesian(xlim=c(0,1))+labs(x="fraction of cell length",y="normalized intensity",title="15- line plots of individual profiles \n")#
#
#================================================================#
#16- line plots split between \nshort & long cells#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",align="orient")#
profileResults$prop_dtable[5]<-profileResults$prop_dtable["y"]/profileResults$ncol>0.5#
names(profileResults$prop_dtable)<- c("cell","x","y","intensity","half")#
#
min<-colQuantiles(profileResults$or_dtable["intensity"],0.05,na.rm=TRUE)#
max<-profileResults$max#
#
pt16<-ggplot() + layer(data=profileResults$prop_dtable, mapping=aes(x=x, y=intensity, group=cell, color=factor(half)), geom="line", alpha=2/sqrt(profileResults$ncol)) + theme_bw(base_size=10) + coord_cartesian(xlim=c(0,1)) + scale_color_brewer(palette="Set1") + scale_fill_brewer(palette="Set1") + theme(legend.position="none") + labs(x="fraction of cell length", y="normalized intensity", title="16- line plots split between short & long cells \n")#
#
#================================================================#
#17- line plots split between short\nmedium & long cells (simple mean & confidence)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",align="orient")#
#
#interpolate profile results to align the data points#
nrow<-profileResults$nrow#
ncol<-profileResults$ncol#
interp_dtable<-matrix(data=NA,nrow=0,ncol=3)#
for (i in 1:ncol){#
	slice<-profileResults$prop_dtable[1:nrow+nrow*(i-1),]#
	len<-length(profileResults$form_dtable[!is.na(profileResults$form_dtable[i]),i])#
	interp<-approx(slice[c(2,4)],n=100)#
	interp_dtable<-rbind(interp_dtable,cbind(interp$x,interp$y,rep(i,100)))#
}#
interp_dtable<-as.data.frame(interp_dtable)#
#
#the next lines add a third colum that defines how to split the cells into categories#
#to swap to the method used for graph 16, comment out the next line, and uncomment the one after it#
interp_dtable[4]<-round(interp_dtable[3]/ncol*2)#
#interp_dtable[4]<-interp_dtable[3]/ncol>0.5#
names(interp_dtable)<-c("x","intensity","cell","half")#
#
min<-profileResults$min#
max<-profileResults$max#
#
pt17<-ggplot() + layer(data=interp_dtable, mapping=aes(x=x, y=intensity, group=cell, color=factor(half)), geom="line", alpha=3/sqrt(profileResults$ncol)) + stat_summary(data=interp_dtable, mapping=aes(x=x, y=intensity, group=factor(half)), fun.data="mean_cl_boot", geom="smooth", alpha=0.75, fill="black") + stat_summary(data=interp_dtable, mapping=aes(x=x, y=intensity, color=factor(half)), fun.y="mean", geom="line") + coord_cartesian(xlim=c(0,1)) + scale_color_brewer(palette="Set1") + scale_fill_brewer(palette="Set1") + theme_bw(base_size=10) + theme(legend.position="none") + labs(x="fraction of cell length", y="normalized intensity", title="17- line plots split between short\nmedium & long cells (simple mean & confidence)")#
#
#note: mean_cl_boot (based on smean.cl.boot from the Hmisc package) is "a very fast implementation of the basic nonparametric bootstrap for obtaining confidence limits for the population mean without assuming normality"#
#
#================================================================#
#18- gaussian kernel density \nplot of cell lengths#
#================================================================#
lengths<-{}#
lengths_temp<-raw_table[seq(1,ncol(raw_table),by=2)]#
for(i in 1:ncol(lengths_temp)){lengths[i]<-max(lengths_temp[i],na.rm=TRUE)}#
lengths<-as.data.frame(lengths)#
#
pt18<-ggplot() + layer(data=lengths, mapping=aes(x=lengths), geom="density") + theme_bw(base_size=10) + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0)) + labs(x="cell length (um)", y="probability density", title="18- gaussian kernel density \nplot of cell lengths")#
#
dev.new(width=8,height=6)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(3,2, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Additional Graph Types and Examples", vp=viewport(layout.pos.row=1,layout.pos.col=1:2),gp=gpar(fontsize=16))#
print(pt15,vp=vplayout(2,1))#
print(pt16,vp=vplayout(2,2))#
cat("This one takes a moment to draw... be patient.")#
print(pt17,vp=vplayout(3,1))#
print(pt18,vp=vplayout(3,2))#
#
{#
#================================================================#
# the following graphs are for documentation purposes only#
#================================================================#
# g<-g + theme_bw(base_size=10)#
# g2<-g2 + theme_bw(base_size=10)#
#
# dev.new(width=8,height=3)#
# grid.newpage()#
# pushViewport(viewport(layout=grid.layout(1,2)))#
# print(g,vp=vplayout(1,1))#
# print(g2,vp=vplayout(1,2))#
#
# dev.new(width=8,height=3)#
# grid.newpage()#
# pushViewport(viewport(layout=grid.layout(1,2)))#
# print(pt3,vp=vplayout(1,1))#
# print(pt4,vp=vplayout(1,2))#
#
# dev.new(width=8,height=3)#
# grid.newpage()#
# pushViewport(viewport(layout=grid.layout(1,2)))#
# print(pt5,vp=vplayout(1,1))#
# print(pt6,vp=vplayout(1,2))#
#
# dev.new(width=8,height=3)#
# grid.newpage()#
# pushViewport(viewport(layout=grid.layout(1,2)))#
# print(pt7,vp=vplayout(1,1))#
# print(pt8,vp=vplayout(1,2))#
#
# dev.new(width=8,height=3)#
# grid.newpage()#
# pushViewport(viewport(layout=grid.layout(1,2)))#
# print(pt9,vp=vplayout(1,1))#
# print(pt11,vp=vplayout(1,2))#
#
# dev.new(width=8,height=3)#
# grid.newpage()#
# pushViewport(viewport(layout=grid.layout(1,2)))#
# print(pt10,vp=vplayout(1,1))#
# print(pt12,vp=vplayout(1,2))#
#
# dev.new(width=8,height=3)#
# grid.newpage()#
# pushViewport(viewport(layout=grid.layout(1,2)))#
# print(pt13,vp=vplayout(1,1))#
# print(pt14,vp=vplayout(1,2))#
#
# dev.new(width=8,height=3)#
# grid.newpage()#
# pushViewport(viewport(layout=grid.layout(1,2)))#
# print(pt18,vp=vplayout(1,1))#
# print(pt15,vp=vplayout(1,2))#
#
# dev.new(width=8,height=3)#
# grid.newpage()#
# pushViewport(viewport(layout=grid.layout(1,2)))#
# print(pt16,vp=vplayout(1,1))#
# print(pt17,vp=vplayout(1,2))#
# #demonstration of dark vs light background#
# profileResults<-cellProfiles(data=dtable,contrast="norm")#
#
# pt19<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="dark background") + theme(panel.background=element_rect(fill="#061542"), panel.grid.minor=element_line(color="#225EA8"), panel.grid.major=element_line(color="#225ea8"))#
#
# pt20<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="light background")#
#
# dev.new(width=8,height=3)#
# grid.newpage()#
# pushViewport(viewport(layout=grid.layout(1,2)))#
# print(pt19,vp=vplayout(1,1))#
# print(pt20,vp=vplayout(1,2))#
}
install.packages("ggplot2",dep=TRUE)#
install.packages("reshape2",dep=TRUE)#
install.packages("hexbin",dep=TRUE)#
install.packages("quantreg",dep=TRUE)#
install.packages("matrixStats",dep=TRUE)#
install.packages("scales",dep=TRUE)#
install.packages("RColorBrewer",dep=TRUE)
library(ggplot2)		#
library(reshape2)#
library(matrixStats)#
library(scales)#
library(grid)#
library(RColorBrewer) 	#for a list of palettes, run: display.brewer.all()
raw_table<-read.table("profiles.csv",header=FALSE,sep=",")
dtable<-cellProfileTruncate(data=raw_table,0)
cellProfiles <- function(data=NULL,position="center",align="native",reverse=FALSE,contrast="native",range=c(0.02,0.98)){#
#============================#
#VERSION 2.4#
#USER GUIDE#
##
#Command line variables#
# Change the behavior of this function by defining these variables when calling it#
##
# 		eg: profileResults <- cellProfiles(data=dtable,align="orient",reverse=TRUE,contrast="normx")#
#		The above command would use the data "dtable" to produce a graph with:#
#			1) cells automatically aligned with the brightest sides [orient]#
#			2) on the *left* [reverse]#
#			3) while applying the normalize function (maximum ratio enforced via truncation) [normx]#
##
# data-handling options#
#  position = "center" or "left"#
#		[DEFAULT]->	center:	 plot with midcells aligned at point zero#
#					left:	plot with left side of cells aligned at zero#
##
#  align 	= "native", "orient", "random", "reuse"#
#		[DEFAULT]->	native:	profiles maintain original alignment#
#					orient:	automatically aligns the cell profiles so that the brightest points are on the same side#
#					random:	cells are randomly flipped#
#					reuse:	apply the last graphed orientations to the current graph#
##
#  reverse	= FALSE or TRUE#
#		[DEFAULT]->	FALSE:	no change in orientation#
#					TRUE:	plot profiles in reverse orientation (can be combined with, eg, align="reuse")#
#					#
# contrast adjustments for graphs	#
#  contrast = "native", "norm", "max"#
#		[DEFAULT]->	native:	profiles maintain original fluorescence intensities#
#					norm:  	divides each profile by its mean value#
#					max:	maximizes contrast #
##
#  range	= c(min,max)	This vector defines the lower and upper percentile boundaries of the color scale#
#		[DEFAULT]->	c(0.02,0.98)		treat these limits like changing the min/max displayed constrast in ImageJ etc#
##
#Exported variables#
# these variables are accessible from the script results. #
##
# 		eg, if you run: profileResults <- cellProfiles(data=dtable)#
# 		then the formatted final table is accessible at profileResults$form_dtable. #
# 		write the table to a new csv file using: #
#				write.csv(as.matrix(profileResults$form_dtable),file="cellprofiles wide format.csv")#
##
# or_dtable		long data table for ggplot#
# lim_or_dtable	long data table for ggplot, with values truncated as defined by the range setting#
# data			input data#
# form_dtable	wide-formatted table for human eyes#
# prop_dtable	long data table, where cell length is converted to fraction of cell length#
# ncol			number of cells measured#
# nrow			length of original data table#
# max			max fluorescence #
# min			min fluorescence#
# med			median fluorescence#
# mid			midpoint between min & max fluorescence#
# maxlength		longest cell length#
##
#END USER GUIDE#
#============================#
	t0<-proc.time()#
#
	#set up a few variables#
	if (local(exists("cellProfilesFunctionEnvironment.env"),envir=.GlobalEnv) == FALSE){local(cellProfilesFunctionEnvironment.env<-new.env(),envir=.GlobalEnv)}#
	if (!(is.vector(range)) || (!(length(range)==2)) || !(range[1]>=0 && range[2]<=1) || !(range[1]<range[2])){#
		cat("ERROR: Range must be between 0 and 1, in the format: c(min,max).");return(NULL)#
	}#
	if (position=="left"){adj_tick<-5} else {adj_tick<-6}#
	cmin<-range[1]#
	cmax<-range[2]#
	ncol<-ncol(data)/2#
	nrow<-nrow(data)#
	dlength<-data[seq(1,ncol*2,by=2)]#
	profile<-data[seq(2,ncol*2,by=2)]#
	maxlength<-ceiling(max(dlength,na.rm=TRUE))#
	wtmeanleft<-log((50:5)/5)/log(10)#
	wtmeanright<-log((5:50)/5)/log(10)#
	#sets up profile fliplist, or preserves prior orientations & disables inappropriate flags#
	if (align == "reuse"){#
		if ((local(exists("fliplist"), envir=cellProfilesFunctionEnvironment.env) != TRUE) || !(ncol == length(local(fliplist, envir=cellProfilesFunctionEnvironment.env)))){#
			cat("ERROR: Use of the align=\"reuse\" option requires prior evaluation of a dataset with the same number of cells... otherwise there is nothing to \"reuse\".")#
			return(NULL)#
		}#
		if (reverse == TRUE){#
			local(fliplist<-(fliplist-1)/-1, envir=cellProfilesFunctionEnvironment.env)#
		}#
	} else {#
		cellProfilesFunctionEnvironment.env$fliplist<-rep(1,ncol)#
		if (align == "random"){#
			cellProfilesFunctionEnvironment.env$fliplist[sample(ncol,ncol/2)]<-0#
		}#
	}#
	#perform contrast adjustments and aligns or randomizes data as set in the options above#
	cat("Calculating: \n ..")#
	tick<-txtProgressBar(min=1,max=ncol*adj_tick,style=3)#
	tmp_profile<-profile#
	for(ii in 1:ncol){#
		#for orient flag, find out if the top half of the column is brighter than the bottom half#
		#if not, then set fliplist[ii] to 1 so the column will be reversed#
		real_rows<-colCounts(as.matrix(profile[ii]+1),na.rm=TRUE)#
		half_rows<-round(real_rows/2)#
		if ((align == "orient") && mean(profile[1:half_rows,ii]*approx(wtmeanleft,n=half_rows)$y) < mean(profile[(real_rows-half_rows+1):real_rows,ii]*approx(wtmeanright,n=half_rows)$y)){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-0#
		}#
		if ((reverse == TRUE) && (align != "reuse")){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-(cellProfilesFunctionEnvironment.env$fliplist[ii]-1)/-1#
		}#
		#normalize profile data, as appropriate#
		if (contrast == "norm"){#
			col_mean<-mean(as.matrix(profile[ii]),na.rm=TRUE)#
			profile[ii]<-(profile[ii]/col_mean)#
		}#
		#col_min & max are used to adjust contrast when max contrast is called		#
		if (contrast != "max"){#
			col_min<-0#
			col_max<-1#
		}	else {#
			col_min<-min(profile[ii],na.rm=TRUE)	#
			col_max<-max(profile[ii],na.rm=TRUE)-col_min#
		}#
		#save flipped/reversed/contrast adjusted values into tmp_profile, as appropriate #
		if (cellProfilesFunctionEnvironment.env$fliplist[ii]==1) {#
			tmp_profile[c(real_rows:1),ii]<-(profile[c(1:real_rows),ii]-col_min)/(col_max)#
		} else {#
			tmp_profile[c(1:real_rows),ii]<-(profile[c(1:real_rows),ii]-col_min)/(col_max)#
		}#
		setTxtProgressBar(tick,ii)#
	}#
	profile<-tmp_profile	#
    #find maximum length of each column, and the number of real values in each column#
    #then order cells by measured cell length values#
	cellength<-{}#
	collength<-{}#
	for(i in 1:ncol){#
		cellength[i]<-max(dlength[i],na.rm=TRUE)#
	}#
	for(i in 1:ncol){#
		collength[i]<-colCounts(as.matrix(profile[i]+1),na.rm=TRUE)#
	}#
	setTxtProgressBar(tick,2*ncol)#
	collength<-order(cellength)#
	#setup the y values to stack each profile#
	plotheight<-{}#
	for(i in 1:ncol){#
		temp<-rep(i,nrow)#
		plotheight<-append(plotheight,temp)#
	}#
	setTxtProgressBar(tick,3*ncol)#
	#shifts cells to center (if center = TRUE)#
	if (position == "center"){#
		for(ii in 1:ncol){#
			col_adj<-(max(dlength[ii],na.rm=TRUE)+min(dlength[ii],na.rm=TRUE))/2#
			dlength[ii]<-dlength[ii]-col_adj#
		}#
	}#
	setTxtProgressBar(tick,(adj_tick-2)*ncol)#
	#apply order info from above#
	or_dlength<-melt(dlength[collength],id=NULL)#
	or_profile<-melt(profile[collength],id=NULL)#
	or_dtable<-cbind(or_dlength,plotheight,or_profile[2])#
	names(or_dtable)<- c("cell","x","y","intensity")#
	max<-max(or_dtable["intensity"],na.rm=TRUE)#
	min<-min(or_dtable["intensity"],na.rm=TRUE)#
	med<-median(as.matrix(or_dtable["intensity"]),na.rm=TRUE)#
	mid<-(max-min)/2+min#
	#simple code to breakdown the long data list into something human-readable#
	fodframe<-as.data.frame(or_profile[1:nrow,2])#
	colnames(fodframe)<-or_profile[1,1]#
	for(c in 2:ncol){#
		odframe<-as.data.frame(or_profile[(1:nrow)+(c-1)*nrow,2])#
		colnames(odframe)<-or_profile[(nrow*c),1]#
		fodframe<-cbind(fodframe,odframe)#
	}		#
	setTxtProgressBar(tick,(adj_tick-1)*ncol)#
	fodframe <- round(fodframe*1000)/1000#
	#prepared a list suitable for making x-y scatter plots (x-axis converted to proportion of cell length)#
	or_dlength<-dlength[collength]#
	for(i in 1:ncol){#
		or_dlength[i]<-rescale(or_dlength[i])#
	}#
	setTxtProgressBar(tick,(adj_tick)*ncol)#
	close(tick)#
	or_dlength<-melt(or_dlength,id=NULL)#
	por_dtable<-cbind(or_dlength,plotheight,or_profile[2])#
	names(por_dtable)<- c("cell","x","y","intensity")#
	#eliminate empty rows#
	or_dtable<-or_dtable[!is.na(or_dtable[4])==TRUE,c(1:4)]#
	#create contrast-truncated version#
	lim_or_dtable<-or_dtable	#
	lim_min<-colQuantiles(or_dtable["intensity"],cmin,na.rm=TRUE)#
	lim_max<-colQuantiles(or_dtable["intensity"],cmax,na.rm=TRUE)#
	cmin_count<-length(lim_or_dtable$intensity[lim_or_dtable$intensity<lim_min])#
	cmax_count<-length(lim_or_dtable$intensity[lim_or_dtable$intensity>lim_max])#
	lim_or_dtable[lim_or_dtable["intensity"]<lim_min,"intensity"]<-lim_min#
	lim_or_dtable[lim_or_dtable["intensity"]>lim_max,"intensity"]<-lim_max#
	len_count<-length(lim_or_dtable$intensity)#
	cat(len_count-cmin_count-cmax_count," profile points (",round(1000*(len_count-cmin_count-cmax_count)/len_count)/10,"%) fall in the range between the lower (",round(100*lim_min[[1]])/100,") and upper (",round(100*lim_max[[1]])/100,") contrast limits.\n",sep="")#
	profileResults <- list("or_dtable"=or_dtable, "lim_or_dtable"=lim_or_dtable, "data"=data, "form_dtable"=fodframe, "prop_dtable"=por_dtable, "ncol"=ncol, "nrow"=nrow, "max"=max, "min"=min, "med"=med, "mid"=mid, "maxlength"=maxlength)#
	tf<-proc.time()-t0#
	cat("Calculations on",ncol,"cells complete in",tf[["elapsed"]],"seconds.")#
	return(profileResults)#
}#
#
cellProfileTruncate <- function(data=NULL,adjust){#
#============================#
#USER GUIDE#
##
# This function will remove [adjust] rows from the beginning and end of each cell#
# Use this function to correct when, for eg, wide selection lines collect too much dark background to accurately represent cell poles#
# Another solution to this problem would be to simply plot the graph background to a dark color#
# eg, add to the ggplot2 code: +theme(panel.background = element_rect(fill="#061542"))#
##
# adjust	= a positive integer. Will normally be 1-3 rows or so, depending on how you measured the data originally#
##
#END USER GUIDE#
#============================#
	#various sanity checks before performing the truncation#
	if (!(is.numeric(adjust) && floor(adjust)==adjust) || (adjust<0)){#
		cat("ERROR: adjustment value must be a positive integer.");return(NULL)#
	}#
	if (adjust == 0){#
		return(data)#
	} else if (adjust >= nrow(na.omit(data))/2){#
		cat("ERROR: cannot truncate more rows than exist. Must be",floor(nrow(na.omit(data))/2),"or fewer rows.");return(NULL)#
	} else if (2*adjust/nrow(na.omit(data)) > 0.25){#
		cat("WARNING: truncating ",round(100*2*adjust/nrow(na.omit(data))),"% of the shortest cell. This seems unwise.",sep="")#
	}#
	tmp_dtable<-matrix(NA,nrow(data),ncol(data))#
	#it is pretty easy to lop off the top of the table#
	data<-data[1+adjust:nrow(data),]#
	#however, taking off the bottom rows from each column (of different lengths) is rather more complicated#
	#below is an optimized form of a for loop that would copy, 2 columns at a time, all but the bottom [adjust] row(s)#
	for(i in seq(1,ncol(data),by=2)){#
		tmp_dtable[1:(nrow(as.matrix(data[!is.na(data[,i]),c(i)]))-adjust),c(i,i+1)]<-as.matrix(data[1:(nrow(as.matrix(data[!is.na(data[,i]),c(i)]))-adjust),c(i,i+1)])#
	}#
	return(as.data.frame(tmp_dtable))#
}#
#
library(ggplot2)  	#
library(reshape2)#
library(matrixStats)#
library(scales)#
library(grid)#
library(RColorBrewer)
dtable<-cellProfileTruncate(data=raw_table,0)
#CENTERED -norm#
profileResults<-cellProfiles(data=dtable,contrast="norm")#
#
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
profileResults<-cellProfiles(data=dtable,position="left",contrast="norm")#
#
g2<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="cell length (um)",y="fraction of cell cycle",title="2- position=\"left\"")#
#
dev.new(width=4.86,height=3.4)#
g2
rev(brewer.pal(9, "YlGnBu"))
colorRampPalette(rev(brewer.pal(11, "Spectral")))
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=colorRampPalette(rev(brewer.pal(11, "Spectral")))) + scale_color_gradientn(colours=colorRampPalette(rev(brewer.pal(11, "Spectral")))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")
colPal <- colorRampPalette(rev(brewer.pal(11, "Spectral")))
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=colPal(100)) + scale_color_gradientn(colours=colPal()) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=colPal(100)) + scale_color_gradientn(colours=colPal(100)) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")
dev.new(width=4.86,height=3.4)#
g
colPal <- colorRampPalette(rev(brewer.pal(9, "YlGnBu")))
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=colPal(100)) + scale_color_gradientn(colours=colPal(100)) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=colPal(256)) + scale_color_gradientn(colours=colPal(256)) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
g2<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="cell length (um)",y="fraction of cell cycle",title="2- position=\"left\"")#
#
dev.new(width=4.86,height=3.4)#
g2
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=colPal(256)) + scale_color_gradientn(colours=colPal(256)) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_continuous(colours=colPal(256)) + scale_color_continuous(colours=colPal(256)) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
g2<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu")), guide="colourbar") + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu")), guide="colourbar") + labs(x="cell length (um)",y="fraction of cell cycle",title="2- position=\"left\"")
dev.new(width=4.86,height=3.4)#
g2
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=colPal(256), guide="colourbar") + scale_color_gradientn(colours=colPal(256), guide="colourbar") + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")
dev.new(width=4.86,height=3.4)#
g
#================================================================#
#EXAMPLES OF GRAPHING OPTIONS #
#================================================================#
#The following graphs demonstrate the different graphing options available#
#Select from here to the bottom and execute to view them all#
raw_table<-read.table("profiles.csv",header=FALSE,sep=",")#
dtable<-cellProfileTruncate(data=raw_table,0)#
vplayout<-function(x,y) viewport(layout.pos.row=x,layout.pos.col=y)#
#
standard_theme	<-theme_bw(base_size=10)#
standard_labs	<-labs(x="distance from midcell (um)",y="fraction of cell cycle")#
standard_y		<-scale_y_continuous(expand=c(0,0),breaks=seq(0,1,0.25),trans="reverse")#
standard_fill	<-scale_fill_gradientn(colours=rev(brewer.pal(9,"YlGnBu")))#
standard_color	<-scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu")))#
standard_layer	<-function(x1,x2) layer(geom="tile",width=1.01*(x1-x2),size=0.25)#
#
dev.new(width=8,height=3.25)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(2,2, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Position Options", vp=viewport(layout.pos.row=1,layout.pos.col=1:2),gp=gpar(fontsize=16))#
print(g,vp=vplayout(2,1))#
print(g2,vp=vplayout(2,2))#
#
#================================================================#
#3- native#
#================================================================#
profileResults<-cellProfiles(data=dtable)#
#
pt3<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="3- contrast=\"native\"\n")#
#
#================================================================#
#4- max range=c(0,1)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="max",range=c(0,1))#
#
pt4<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + standard_labs+labs(title="4- contrast=\"max\",\n range=c(0,1)")#
#
#================================================================#
#5- norm range=c(0,1)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0,1))#
#
pt5<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="5- contrast=\"norm\",\n range=c(0,1)")#
#
#================================================================#
#6- norm range=c(0.005,0.995)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0.005,0.995))#
#
pt6<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="6- contrast=\"norm\",\n range=c(0.005,0.995)")#
#
#================================================================#
#7- norm range=c(0.02,0.98)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0.02,0.98))#
#
pt7<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="7- contrast=\"norm\",\n range=c(0.02,0.98)")#
#
#================================================================#
#8- norm range=c(0.05,0.95)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0.05,0.95))#
#
pt8<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="8- contrast=\"norm\",\n range=c(0.05,0.95)")#
#
dev.new(width=12,height=6.4)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(3,3, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Contrast Options", vp=viewport(layout.pos.row=1,layout.pos.col=1:3),gp=gpar(fontsize=16))#
print(pt3,vp=vplayout(2,1))#
print(pt5,vp=vplayout(2,2))#
print(pt6,vp=vplayout(2,3))#
print(pt4,vp=vplayout(3,1))#
print(pt7,vp=vplayout(3,2))#
print(pt8,vp=vplayout(3,3))
raw_table<-read.csv("profiles.csv",header=FALSE,sep=",")
dtable<-cellProfileTruncate(data=raw_table,0)
#CENTERED -norm#
profileResults<-cellProfiles(data=dtable,contrast="norm")#
#
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g#
#NOT CENTERED -norm#
profileResults<-cellProfiles(data=dtable,position="left",contrast="norm")#
#
g2<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="cell length (um)",y="fraction of cell cycle",title="2- position=\"left\"")#
#
dev.new(width=4.86,height=3.4)#
g2
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
profileResults<-cellProfiles(data=dtable,contrast="native")
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
profileResults<-cellProfiles(data=dtable,contrast="native")#
#
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
profileResults<-cellProfiles(data=dtable,contrast="norm")#
#
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
#================================================================#
#INTENSITY HEAT MAPS OVER CELL LENGTH#
#be sure to load the cellProfiles function first!#
#================================================================#
#
#commands for changing to a specific directory & load data tables#
#assumes there is no header... use header=TRUE if there is one#
#setwd("")#
raw_table<-read.table("profiles.csv",header=FALSE,sep=",")#
#
#slightly truncate the poles to remove dark polar bands (artifact from width of profile line)#
dtable<-cellProfileTruncate(data=raw_table,0)#
#
#================================================================#
#the following two graphs are general templates suitable for most data & purposes (in centered, and non-centered versions)#
#================================================================#
#
#CENTERED -norm#
profileResults<-cellProfiles(data=dtable,contrast="norm")#
#
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g#
#NOT CENTERED -norm#
profileResults<-cellProfiles(data=dtable,position="left",contrast="norm")#
#
g2<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="cell length (um)",y="fraction of cell cycle",title="2- position=\"left\"")#
#
dev.new(width=4.86,height=3.4)#
g2#
#================================================================#
#EXAMPLES OF GRAPHING OPTIONS #
#================================================================#
#The following graphs demonstrate the different graphing options available#
#Select from here to the bottom and execute to view them all#
raw_table<-read.table("profiles.csv",header=FALSE,sep=",")#
dtable<-cellProfileTruncate(data=raw_table,0)#
vplayout<-function(x,y) viewport(layout.pos.row=x,layout.pos.col=y)#
#
standard_theme	<-theme_bw(base_size=10)#
standard_labs	<-labs(x="distance from midcell (um)",y="fraction of cell cycle")#
standard_y		<-scale_y_continuous(expand=c(0,0),breaks=seq(0,1,0.25),trans="reverse")#
standard_fill	<-scale_fill_gradientn(colours=rev(brewer.pal(9,"YlGnBu")))#
standard_color	<-scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu")))#
standard_layer	<-function(x1,x2) layer(geom="tile",width=1.01*(x1-x2),size=0.25)#
#
dev.new(width=8,height=3.25)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(2,2, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Position Options", vp=viewport(layout.pos.row=1,layout.pos.col=1:2),gp=gpar(fontsize=16))#
print(g,vp=vplayout(2,1))#
print(g2,vp=vplayout(2,2))#
#
#================================================================#
#3- native#
#================================================================#
profileResults<-cellProfiles(data=dtable)#
#
pt3<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="3- contrast=\"native\"\n")#
#
#================================================================#
#4- max range=c(0,1)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="max",range=c(0,1))#
#
pt4<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + standard_labs+labs(title="4- contrast=\"max\",\n range=c(0,1)")#
#
#================================================================#
#5- norm range=c(0,1)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0,1))#
#
pt5<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="5- contrast=\"norm\",\n range=c(0,1)")#
#
#================================================================#
#6- norm range=c(0.005,0.995)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0.005,0.995))#
#
pt6<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="6- contrast=\"norm\",\n range=c(0.005,0.995)")#
#
#================================================================#
#7- norm range=c(0.02,0.98)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0.02,0.98))#
#
pt7<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="7- contrast=\"norm\",\n range=c(0.02,0.98)")#
#
#================================================================#
#8- norm range=c(0.05,0.95)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0.05,0.95))#
#
pt8<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="8- contrast=\"norm\",\n range=c(0.05,0.95)")#
#
dev.new(width=12,height=6.4)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(3,3, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Contrast Options", vp=viewport(layout.pos.row=1,layout.pos.col=1:3),gp=gpar(fontsize=16))#
print(pt3,vp=vplayout(2,1))#
print(pt5,vp=vplayout(2,2))#
print(pt6,vp=vplayout(2,3))#
print(pt4,vp=vplayout(3,1))#
print(pt7,vp=vplayout(3,2))#
print(pt8,vp=vplayout(3,3))#
#================================================================#
#9- native#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="max")#
#
pt9<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="9- align=\"native\",\n contrast=\"max\"")#
#
#================================================================#
#10- orient#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="orient",contrast="max")#
#
pt10<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="10- align=\"orient\",\n contrast=\"max\"")#
#
#================================================================#
#11- random#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="random",contrast="max")#
#
pt11<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs+labs(title="11- align=\"random\",\n contrast=\"max\"")#
#
#================================================================#
#12- orient / reverse#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="orient",contrast="max",reverse=TRUE)#
#
pt12<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="12- align=\"orient\", reverse=TRUE, \ncontrast=\"max\"")#
#
#================================================================#
#13- reuse / reverse #1#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="reuse",contrast="max",reverse=TRUE)#
#
pt13<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="13- align=\"reuse\", reverse=TRUE, \ncontrast=\"max\"")#
#
#================================================================#
#14- reuse / reverse #2#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="reuse",contrast="max",reverse=TRUE)#
#
pt14<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="14- align=\"reuse\", reverse=TRUE, \ncontrast=\"max\"")#
#
dev.new(width=12,height=6.4)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(3,3, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Alignment Options", vp=viewport(layout.pos.row=1,layout.pos.col=1:3),gp=gpar(fontsize=16))#
print(pt9,vp=vplayout(2,1))#
print(pt10,vp=vplayout(2,2))#
print(pt11,vp=vplayout(2,3))#
print(pt12,vp=vplayout(3,1))#
print(pt13,vp=vplayout(3,2))#
print(pt14,vp=vplayout(3,3))#
#
#================================================================#
#15- line plots of individual profiles \n#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",align="orient")#
#
pt15<-ggplot()+layer(data=profileResults$prop_dtable,mapping=aes(x=x,y=intensity,group=cell),geom="line",alpha=1/sqrt(profileResults$ncol))+theme_bw(base_size=10)+coord_cartesian(xlim=c(0,1))+labs(x="fraction of cell length",y="normalized intensity",title="15- line plots of individual profiles \n")#
#
#================================================================#
#16- line plots split between \nshort & long cells#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",align="orient")#
profileResults$prop_dtable[5]<-profileResults$prop_dtable["y"]/profileResults$ncol>0.5#
names(profileResults$prop_dtable)<- c("cell","x","y","intensity","half")#
#
min<-colQuantiles(profileResults$or_dtable["intensity"],0.05,na.rm=TRUE)#
max<-profileResults$max#
#
pt16<-ggplot() + layer(data=profileResults$prop_dtable, mapping=aes(x=x, y=intensity, group=cell, color=factor(half)), geom="line", alpha=2/sqrt(profileResults$ncol)) + theme_bw(base_size=10) + coord_cartesian(xlim=c(0,1)) + scale_color_brewer(palette="Set1") + scale_fill_brewer(palette="Set1") + theme(legend.position="none") + labs(x="fraction of cell length", y="normalized intensity", title="16- line plots split between short & long cells \n")#
#
#================================================================#
#17- line plots split between short\nmedium & long cells (simple mean & confidence)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",align="orient")#
#
#interpolate profile results to align the data points#
nrow<-profileResults$nrow#
ncol<-profileResults$ncol#
interp_dtable<-matrix(data=NA,nrow=0,ncol=3)#
for (i in 1:ncol){#
	slice<-profileResults$prop_dtable[1:nrow+nrow*(i-1),]#
	len<-length(profileResults$form_dtable[!is.na(profileResults$form_dtable[i]),i])#
	interp<-approx(slice[c(2,4)],n=100)#
	interp_dtable<-rbind(interp_dtable,cbind(interp$x,interp$y,rep(i,100)))#
}#
interp_dtable<-as.data.frame(interp_dtable)#
#
#the next lines add a third colum that defines how to split the cells into categories#
#to swap to the method used for graph 16, comment out the next line, and uncomment the one after it#
interp_dtable[4]<-round(interp_dtable[3]/ncol*2)#
#interp_dtable[4]<-interp_dtable[3]/ncol>0.5#
names(interp_dtable)<-c("x","intensity","cell","half")#
#
min<-profileResults$min#
max<-profileResults$max#
#
pt17<-ggplot() + layer(data=interp_dtable, mapping=aes(x=x, y=intensity, group=cell, color=factor(half)), geom="line", alpha=3/sqrt(profileResults$ncol)) + stat_summary(data=interp_dtable, mapping=aes(x=x, y=intensity, group=factor(half)), fun.data="mean_cl_boot", geom="smooth", alpha=0.75, fill="black") + stat_summary(data=interp_dtable, mapping=aes(x=x, y=intensity, color=factor(half)), fun.y="mean", geom="line") + coord_cartesian(xlim=c(0,1)) + scale_color_brewer(palette="Set1") + scale_fill_brewer(palette="Set1") + theme_bw(base_size=10) + theme(legend.position="none") + labs(x="fraction of cell length", y="normalized intensity", title="17- line plots split between short\nmedium & long cells (simple mean & confidence)")#
#
#note: mean_cl_boot (based on smean.cl.boot from the Hmisc package) is "a very fast implementation of the basic nonparametric bootstrap for obtaining confidence limits for the population mean without assuming normality"#
#
#================================================================#
#18- gaussian kernel density \nplot of cell lengths#
#================================================================#
lengths<-{}#
lengths_temp<-raw_table[seq(1,ncol(raw_table),by=2)]#
for(i in 1:ncol(lengths_temp)){lengths[i]<-max(lengths_temp[i],na.rm=TRUE)}#
lengths<-as.data.frame(lengths)#
#
pt18<-ggplot() + layer(data=lengths, mapping=aes(x=lengths), geom="density") + theme_bw(base_size=10) + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0)) + labs(x="cell length (um)", y="probability density", title="18- gaussian kernel density \nplot of cell lengths")#
#
dev.new(width=8,height=6)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(3,2, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Additional Graph Types and Examples", vp=viewport(layout.pos.row=1,layout.pos.col=1:2),gp=gpar(fontsize=16))#
print(pt15,vp=vplayout(2,1))#
print(pt16,vp=vplayout(2,2))#
cat("This one takes a moment to draw... be patient.")#
print(pt17,vp=vplayout(3,1))#
print(pt18,vp=vplayout(3,2))
t0<-proc.time()
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
t0<-proc.time()
if (local(exists("cellProfilesFunctionEnvironment.env"),envir=.GlobalEnv) == FALSE){local(cellProfilesFunctionEnvironment.env<-new.env(),envir=.GlobalEnv)}#
	if (!(is.vector(range)) || (!(length(range)==2)) || !(range[1]>=0 && range[2]<=1) || !(range[1]<range[2])){#
		cat("ERROR: Range must be between 0 and 1, in the format: c(min,max).");return(NULL)#
	}#
	if (position=="left"){adj_tick<-5} else {adj_tick<-6}#
	cmin<-range[1]#
	cmax<-range[2]#
	ncol<-ncol(data)/2#
	nrow<-nrow(data)#
	dlength<-data[seq(1,ncol*2,by=2)]#
	profile<-data[seq(2,ncol*2,by=2)]#
	maxlength<-ceiling(max(dlength,na.rm=TRUE))#
	wtmeanleft<-log((50:5)/5)/log(10)#
	wtmeanright<-log((5:50)/5)/log(10)
data <- raw_table
position <- "center"
align <- "native"
reverse <- FALSE
contrast <- "native"
range <- c(0.02,0.98)
t0<-proc.time()#
#
	#set up a few variables#
	if (local(exists("cellProfilesFunctionEnvironment.env"),envir=.GlobalEnv) == FALSE){local(cellProfilesFunctionEnvironment.env<-new.env(),envir=.GlobalEnv)}#
	if (!(is.vector(range)) || (!(length(range)==2)) || !(range[1]>=0 && range[2]<=1) || !(range[1]<range[2])){#
		cat("ERROR: Range must be between 0 and 1, in the format: c(min,max).");return(NULL)#
	}
if (position=="left"){adj_tick<-5} else {adj_tick<-6}#
	cmin<-range[1]#
	cmax<-range[2]#
	ncol<-ncol(data)/2#
	nrow<-nrow(data)#
	dlength<-data[seq(1,ncol*2,by=2)]#
	profile<-data[seq(2,ncol*2,by=2)]#
	maxlength<-ceiling(max(dlength,na.rm=TRUE))#
	wtmeanleft<-log((50:5)/5)/log(10)#
	wtmeanright<-log((5:50)/5)/log(10)
#sets up profile fliplist, or preserves prior orientations & disables inappropriate flags#
	if (align == "reuse"){#
		if ((local(exists("fliplist"), envir=cellProfilesFunctionEnvironment.env) != TRUE) || !(ncol == length(local(fliplist, envir=cellProfilesFunctionEnvironment.env)))){#
			cat("ERROR: Use of the align=\"reuse\" option requires prior evaluation of a dataset with the same number of cells... otherwise there is nothing to \"reuse\".")#
			return(NULL)#
		}#
		if (reverse == TRUE){#
			local(fliplist<-(fliplist-1)/-1, envir=cellProfilesFunctionEnvironment.env)#
		}#
	} else {#
		cellProfilesFunctionEnvironment.env$fliplist<-rep(1,ncol)#
		if (align == "random"){#
			cellProfilesFunctionEnvironment.env$fliplist[sample(ncol,ncol/2)]<-0#
		}#
	}
cmin
cmax
ncol
nrow
dlength
profile
maxlength
wtmeanleft
wtmeanright
fliplist
ls()
reverse
cellProfilesFunctionEnvironment.env$fliplist
cat("Calculating: \n ..")#
	tick<-txtProgressBar(min=1,max=ncol*adj_tick,style=3)#
	tmp_profile<-profile
for(ii in 1:ncol){#
		#for orient flag, find out if the top half of the column is brighter than the bottom half#
		#if not, then set fliplist[ii] to 1 so the column will be reversed#
		real_rows<-colCounts(as.matrix(profile[ii]+1),na.rm=TRUE)#
		half_rows<-round(real_rows/2)#
		if ((align == "orient") && mean(profile[1:half_rows,ii]*approx(wtmeanleft,n=half_rows)$y) < mean(profile[(real_rows-half_rows+1):real_rows,ii]*approx(wtmeanright,n=half_rows)$y)){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-0#
		}#
		if ((reverse == TRUE) && (align != "reuse")){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-(cellProfilesFunctionEnvironment.env$fliplist[ii]-1)/-1#
		}#
		#normalize profile data, as appropriate#
		if (contrast == "norm"){#
			col_mean<-mean(as.matrix(profile[ii]),na.rm=TRUE)#
			profile[ii]<-(profile[ii]/col_mean)#
		}#
		#col_min & max are used to adjust contrast when max contrast is called		#
		if (contrast != "max"){#
			col_min<-0#
			col_max<-1#
		}	else {#
			col_min<-min(profile[ii],na.rm=TRUE)	#
			col_max<-max(profile[ii],na.rm=TRUE)-col_min#
		}#
		#save flipped/reversed/contrast adjusted values into tmp_profile, as appropriate #
		if (cellProfilesFunctionEnvironment.env$fliplist[ii]==1) {#
			tmp_profile[c(real_rows:1),ii]<-(profile[c(1:real_rows),ii]-col_min)/(col_max)#
		} else {#
			tmp_profile[c(1:real_rows),ii]<-(profile[c(1:real_rows),ii]-col_min)/(col_max)#
		}#
		setTxtProgressBar(tick,ii)#
	}
tmp_profile
profile <- tmp_profile
cellength<-{}
collength<-{}
for(i in 1:ncol){#
		cellength[i]<-max(dlength[i],na.rm=TRUE)#
	}#
	for(i in 1:ncol){#
		collength[i]<-colCounts(as.matrix(profile[i]+1),na.rm=TRUE)#
	}#
	setTxtProgressBar(tick,2*ncol)#
	collength<-order(cellength)
#setup the y values to stack each profile#
	plotheight<-{}#
	for(i in 1:ncol){#
		temp<-rep(i,nrow)#
		plotheight<-append(plotheight,temp)#
	}#
	setTxtProgressBar(tick,3*ncol)
#shifts cells to center (if center = TRUE)#
	if (position == "center"){#
		for(ii in 1:ncol){#
			col_adj<-(max(dlength[ii],na.rm=TRUE)+min(dlength[ii],na.rm=TRUE))/2#
			dlength[ii]<-dlength[ii]-col_adj#
		}#
	}#
	setTxtProgressBar(tick,(adj_tick-2)*ncol)
#apply order info from above#
	or_dlength<-melt(dlength[collength],id=NULL)#
	or_profile<-melt(profile[collength],id=NULL)#
	or_dtable<-cbind(or_dlength,plotheight,or_profile[2])#
	names(or_dtable)<- c("cell","x","y","intensity")
max<-max(or_dtable["intensity"],na.rm=TRUE)#
	min<-min(or_dtable["intensity"],na.rm=TRUE)#
	med<-median(as.matrix(or_dtable["intensity"]),na.rm=TRUE)#
	mid<-(max-min)/2+min
max
min
med
mid
#simple code to breakdown the long data list into something human-readable#
	fodframe<-as.data.frame(or_profile[1:nrow,2])#
	colnames(fodframe)<-or_profile[1,1]#
	for(c in 2:ncol){#
		odframe<-as.data.frame(or_profile[(1:nrow)+(c-1)*nrow,2])#
		colnames(odframe)<-or_profile[(nrow*c),1]#
		fodframe<-cbind(fodframe,odframe)#
	}		#
	setTxtProgressBar(tick,(adj_tick-1)*ncol)#
	fodframe <- round(fodframe*1000)/1000
#prepared a list suitable for making x-y scatter plots (x-axis converted to proportion of cell length)#
	or_dlength<-dlength[collength]#
	for(i in 1:ncol){#
		or_dlength[i]<-rescale(or_dlength[i])#
	}#
	setTxtProgressBar(tick,(adj_tick)*ncol)#
	close(tick)#
	or_dlength<-melt(or_dlength,id=NULL)#
	por_dtable<-cbind(or_dlength,plotheight,or_profile[2])#
	names(por_dtable)<- c("cell","x","y","intensity")#
	#eliminate empty rows#
	or_dtable<-or_dtable[!is.na(or_dtable[4])==TRUE,c(1:4)]
#create contrast-truncated version#
	lim_or_dtable<-or_dtable	#
	lim_min<-colQuantiles(or_dtable["intensity"],cmin,na.rm=TRUE)#
	lim_max<-colQuantiles(or_dtable["intensity"],cmax,na.rm=TRUE)#
	cmin_count<-length(lim_or_dtable$intensity[lim_or_dtable$intensity<lim_min])#
	cmax_count<-length(lim_or_dtable$intensity[lim_or_dtable$intensity>lim_max])#
	lim_or_dtable[lim_or_dtable["intensity"]<lim_min,"intensity"]<-lim_min#
	lim_or_dtable[lim_or_dtable["intensity"]>lim_max,"intensity"]<-lim_max#
	len_count<-length(lim_or_dtable$intensity)#
	cat(len_count-cmin_count-cmax_count," profile points (",round(1000*(len_count-cmin_count-cmax_count)/len_count)/10,"%) fall in the range between the lower (",round(100*lim_min[[1]])/100,") and upper (",round(100*lim_max[[1]])/100,") contrast limits.\n",sep="")
profileResults <- list("or_dtable"=or_dtable, "lim_or_dtable"=lim_or_dtable, "data"=data, "form_dtable"=fodframe, "prop_dtable"=por_dtable, "ncol"=ncol, "nrow"=nrow, "max"=max, "min"=min, "med"=med, "mid"=mid, "maxlength"=maxlength)#
	tf<-proc.time()-t0#
	cat("Calculations on",ncol,"cells complete in",tf[["elapsed"]],"seconds.")
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
profileResults<-cellProfiles(data=dtable,contrast="norm")#
#
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
data <- raw_table#
position <- "center"#
align <- "norm"#
reverse <- FALSE#
contrast <- "native"#
range <- c(0.02,0.98)#
#
	t0<-proc.time()#
#
	#set up a few variables#
	if (local(exists("cellProfilesFunctionEnvironment.env"),envir=.GlobalEnv) == FALSE){local(cellProfilesFunctionEnvironment.env<-new.env(),envir=.GlobalEnv)}#
	if (!(is.vector(range)) || (!(length(range)==2)) || !(range[1]>=0 && range[2]<=1) || !(range[1]<range[2])){#
		cat("ERROR: Range must be between 0 and 1, in the format: c(min,max).");return(NULL)#
	}#
	if (position=="left"){adj_tick<-5} else {adj_tick<-6}#
	cmin<-range[1]#
	cmax<-range[2]#
	ncol<-ncol(data)/2#
	nrow<-nrow(data)#
	dlength<-data[seq(1,ncol*2,by=2)]#
	profile<-data[seq(2,ncol*2,by=2)]#
	maxlength<-ceiling(max(dlength,na.rm=TRUE))#
	wtmeanleft<-log((50:5)/5)/log(10)#
	wtmeanright<-log((5:50)/5)/log(10)
#sets up profile fliplist, or preserves prior orientations & disables inappropriate flags#
	if (align == "reuse"){#
		if ((local(exists("fliplist"), envir=cellProfilesFunctionEnvironment.env) != TRUE) || !(ncol == length(local(fliplist, envir=cellProfilesFunctionEnvironment.env)))){#
			cat("ERROR: Use of the align=\"reuse\" option requires prior evaluation of a dataset with the same number of cells... otherwise there is nothing to \"reuse\".")#
			return(NULL)#
		}#
		if (reverse == TRUE){#
			local(fliplist<-(fliplist-1)/-1, envir=cellProfilesFunctionEnvironment.env)#
		}#
	} else {#
		cellProfilesFunctionEnvironment.env$fliplist<-rep(1,ncol)#
		if (align == "random"){#
			cellProfilesFunctionEnvironment.env$fliplist[sample(ncol,ncol/2)]<-0#
		}#
	}
#perform contrast adjustments and aligns or randomizes data as set in the options above#
	cat("Calculating: \n ..")#
	tick<-txtProgressBar(min=1,max=ncol*adj_tick,style=3)#
	tmp_profile<-profile
for(ii in 1:ncol){#
		#for orient flag, find out if the top half of the column is brighter than the bottom half#
		#if not, then set fliplist[ii] to 1 so the column will be reversed#
		real_rows<-colCounts(as.matrix(profile[ii]+1),na.rm=TRUE)#
		half_rows<-round(real_rows/2)#
		if ((align == "orient") && mean(profile[1:half_rows,ii]*approx(wtmeanleft,n=half_rows)$y) < mean(profile[(real_rows-half_rows+1):real_rows,ii]*approx(wtmeanright,n=half_rows)$y)){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-0#
		}#
		if ((reverse == TRUE) && (align != "reuse")){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-(cellProfilesFunctionEnvironment.env$fliplist[ii]-1)/-1#
		}#
		#normalize profile data, as appropriate#
		if (contrast == "norm"){#
			col_mean<-mean(as.matrix(profile[ii]),na.rm=TRUE)#
			profile[ii]<-(profile[ii]/col_mean)#
		}#
		#col_min & max are used to adjust contrast when max contrast is called		#
		if (contrast != "max"){#
			col_min<-0#
			col_max<-1#
		}	else {#
			col_min<-min(profile[ii],na.rm=TRUE)	#
			col_max<-max(profile[ii],na.rm=TRUE)-col_min#
		}#
		#save flipped/reversed/contrast adjusted values into tmp_profile, as appropriate #
		if (cellProfilesFunctionEnvironment.env$fliplist[ii]==1) {#
			tmp_profile[c(real_rows:1),ii]<-(profile[c(1:real_rows),ii]-col_min)/(col_max)#
		} else {#
			tmp_profile[c(1:real_rows),ii]<-(profile[c(1:real_rows),ii]-col_min)/(col_max)#
		}#
		setTxtProgressBar(tick,ii)#
	}
tmp_profile
profile
tmp_profile
profile <- tmp_profile
#find maximum length of each column, and the number of real values in each column#
    #then order cells by measured cell length values#
	cellength<-{}#
	collength<-{}#
	for(i in 1:ncol){#
		cellength[i]<-max(dlength[i],na.rm=TRUE)#
	}#
	for(i in 1:ncol){#
		collength[i]<-colCounts(as.matrix(profile[i]+1),na.rm=TRUE)#
	}#
	setTxtProgressBar(tick,2*ncol)#
	collength<-order(cellength)#
	#setup the y values to stack each profile#
	plotheight<-{}#
	for(i in 1:ncol){#
		temp<-rep(i,nrow)#
		plotheight<-append(plotheight,temp)#
	}#
	setTxtProgressBar(tick,3*ncol)
#shifts cells to center (if center = TRUE)#
	if (position == "center"){#
		for(ii in 1:ncol){#
			col_adj<-(max(dlength[ii],na.rm=TRUE)+min(dlength[ii],na.rm=TRUE))/2#
			dlength[ii]<-dlength[ii]-col_adj#
		}#
	}#
	setTxtProgressBar(tick,(adj_tick-2)*ncol)#
	#apply order info from above#
	or_dlength<-melt(dlength[collength],id=NULL)#
	or_profile<-melt(profile[collength],id=NULL)#
	or_dtable<-cbind(or_dlength,plotheight,or_profile[2])#
	names(or_dtable)<- c("cell","x","y","intensity")#
	max<-max(or_dtable["intensity"],na.rm=TRUE)#
	min<-min(or_dtable["intensity"],na.rm=TRUE)#
	med<-median(as.matrix(or_dtable["intensity"]),na.rm=TRUE)#
	mid<-(max-min)/2+min#
	#simple code to breakdown the long data list into something human-readable#
	fodframe<-as.data.frame(or_profile[1:nrow,2])#
	colnames(fodframe)<-or_profile[1,1]#
	for(c in 2:ncol){#
		odframe<-as.data.frame(or_profile[(1:nrow)+(c-1)*nrow,2])#
		colnames(odframe)<-or_profile[(nrow*c),1]#
		fodframe<-cbind(fodframe,odframe)#
	}		#
	setTxtProgressBar(tick,(adj_tick-1)*ncol)#
	fodframe <- round(fodframe*1000)/1000#
	#prepared a list suitable for making x-y scatter plots (x-axis converted to proportion of cell length)#
	or_dlength<-dlength[collength]#
	for(i in 1:ncol){#
		or_dlength[i]<-rescale(or_dlength[i])#
	}#
	setTxtProgressBar(tick,(adj_tick)*ncol)#
	close(tick)#
	or_dlength<-melt(or_dlength,id=NULL)#
	por_dtable<-cbind(or_dlength,plotheight,or_profile[2])#
	names(por_dtable)<- c("cell","x","y","intensity")#
	#eliminate empty rows#
	or_dtable<-or_dtable[!is.na(or_dtable[4])==TRUE,c(1:4)]#
	#create contrast-truncated version#
	lim_or_dtable<-or_dtable	#
	lim_min<-colQuantiles(or_dtable["intensity"],cmin,na.rm=TRUE)#
	lim_max<-colQuantiles(or_dtable["intensity"],cmax,na.rm=TRUE)#
	cmin_count<-length(lim_or_dtable$intensity[lim_or_dtable$intensity<lim_min])#
	cmax_count<-length(lim_or_dtable$intensity[lim_or_dtable$intensity>lim_max])#
	lim_or_dtable[lim_or_dtable["intensity"]<lim_min,"intensity"]<-lim_min#
	lim_or_dtable[lim_or_dtable["intensity"]>lim_max,"intensity"]<-lim_max#
	len_count<-length(lim_or_dtable$intensity)#
	cat(len_count-cmin_count-cmax_count," profile points (",round(1000*(len_count-cmin_count-cmax_count)/len_count)/10,"%) fall in the range between the lower (",round(100*lim_min[[1]])/100,") and upper (",round(100*lim_max[[1]])/100,") contrast limits.\n",sep="")#
	profileResults <- list("or_dtable"=or_dtable, "lim_or_dtable"=lim_or_dtable, "data"=data, "form_dtable"=fodframe, "prop_dtable"=por_dtable, "ncol"=ncol, "nrow"=nrow, "max"=max, "min"=min, "med"=med, "mid"=mid, "maxlength"=maxlength)#
	tf<-proc.time()-t0#
	cat("Calculations on",ncol,"cells complete in",tf[["elapsed"]],"seconds.")
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
data <- raw_table#
position <- "center"#
align <- "native"#
reverse <- FALSE#
contrast <- "norm"#
range <- c(0.02,0.98)
t0<-proc.time()#
#
	#set up a few variables#
	if (local(exists("cellProfilesFunctionEnvironment.env"),envir=.GlobalEnv) == FALSE){local(cellProfilesFunctionEnvironment.env<-new.env(),envir=.GlobalEnv)}#
	if (!(is.vector(range)) || (!(length(range)==2)) || !(range[1]>=0 && range[2]<=1) || !(range[1]<range[2])){#
		cat("ERROR: Range must be between 0 and 1, in the format: c(min,max).");return(NULL)#
	}#
	if (position=="left"){adj_tick<-5} else {adj_tick<-6}#
	cmin<-range[1]#
	cmax<-range[2]#
	ncol<-ncol(data)/2#
	nrow<-nrow(data)#
	dlength<-data[seq(1,ncol*2,by=2)]#
	profile<-data[seq(2,ncol*2,by=2)]#
	maxlength<-ceiling(max(dlength,na.rm=TRUE))#
	wtmeanleft<-log((50:5)/5)/log(10)#
	wtmeanright<-log((5:50)/5)/log(10)#
	#sets up profile fliplist, or preserves prior orientations & disables inappropriate flags#
	if (align == "reuse"){#
		if ((local(exists("fliplist"), envir=cellProfilesFunctionEnvironment.env) != TRUE) || !(ncol == length(local(fliplist, envir=cellProfilesFunctionEnvironment.env)))){#
			cat("ERROR: Use of the align=\"reuse\" option requires prior evaluation of a dataset with the same number of cells... otherwise there is nothing to \"reuse\".")#
			return(NULL)#
		}#
		if (reverse == TRUE){#
			local(fliplist<-(fliplist-1)/-1, envir=cellProfilesFunctionEnvironment.env)#
		}#
	} else {#
		cellProfilesFunctionEnvironment.env$fliplist<-rep(1,ncol)#
		if (align == "random"){#
			cellProfilesFunctionEnvironment.env$fliplist[sample(ncol,ncol/2)]<-0#
		}#
	}
#perform contrast adjustments and aligns or randomizes data as set in the options above#
	cat("Calculating: \n ..")#
	tick<-txtProgressBar(min=1,max=ncol*adj_tick,style=3)#
	tmp_profile<-profile#
	for(ii in 1:ncol){#
		#for orient flag, find out if the top half of the column is brighter than the bottom half#
		#if not, then set fliplist[ii] to 1 so the column will be reversed#
		real_rows<-colCounts(as.matrix(profile[ii]+1),na.rm=TRUE)#
		half_rows<-round(real_rows/2)#
		if ((align == "orient") && mean(profile[1:half_rows,ii]*approx(wtmeanleft,n=half_rows)$y) < mean(profile[(real_rows-half_rows+1):real_rows,ii]*approx(wtmeanright,n=half_rows)$y)){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-0#
		}#
		if ((reverse == TRUE) && (align != "reuse")){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-(cellProfilesFunctionEnvironment.env$fliplist[ii]-1)/-1#
		}#
		#normalize profile data, as appropriate#
		if (contrast == "norm"){#
			col_mean<-mean(as.matrix(profile[ii]),na.rm=TRUE)#
			profile[ii]<-(profile[ii]/col_mean)#
		}#
		#col_min & max are used to adjust contrast when max contrast is called		#
		if (contrast != "max"){#
			col_min<-0#
			col_max<-1#
		}	else {#
			col_min<-min(profile[ii],na.rm=TRUE)	#
			col_max<-max(profile[ii],na.rm=TRUE)-col_min#
		}#
		#save flipped/reversed/contrast adjusted values into tmp_profile, as appropriate #
		if (cellProfilesFunctionEnvironment.env$fliplist[ii]==1) {#
			tmp_profile[c(real_rows:1),ii]<-(profile[c(1:real_rows),ii]-col_min)/(col_max)#
		} else {#
			tmp_profile[c(1:real_rows),ii]<-(profile[c(1:real_rows),ii]-col_min)/(col_max)#
		}#
		setTxtProgressBar(tick,ii)#
	}
tmp_profile
profile
tmp_profile
ncol
ii <-1
real_rows<-colCounts(as.matrix(profile[ii]+1),na.rm=TRUE)
real_rows
tmp_profile<-profile
profile[ii]
profile[ii]+1
colCounts(as.matrix(profile[ii]+1),na.rm=TRUE)
as.matrix(profile[ii]+1)
profile[ii]
profile[ii]+1
nrow(profile[ii])
na.omit(profile[ii])
nrow(na.omit(profile[ii]))
colCounts(as.matrix(profile[ii]),na.rm=TRUE)
real_rows <- nrow(na.omit(profile[ii]))
real_rows
half_rows
round(real_rows/2)
half_rows <- round(real_rows/2)
half_rows
tmp_profile<-profile#
	for(ii in 1:ncol){#
		#for orient flag, find out if the top half of the column is brighter than the bottom half#
		#if not, then set fliplist[ii] to 1 so the column will be reversed#
		#DEBUG#
		# ii <-1#
		real_rows <- nrow(na.omit(profile[ii]))#
		half_rows <- round(real_rows/2)#
		if ((align == "orient") && mean(profile[1:half_rows,ii]*approx(wtmeanleft,n=half_rows)$y) < mean(profile[(real_rows-half_rows+1):real_rows,ii]*approx(wtmeanright,n=half_rows)$y)){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-0#
		}#
		if ((reverse == TRUE) && (align != "reuse")){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-(cellProfilesFunctionEnvironment.env$fliplist[ii]-1)/-1#
		}#
		#normalize profile data, as appropriate#
		if (contrast == "norm"){#
			col_mean<-mean(as.matrix(profile[ii]),na.rm=TRUE)#
			profile[ii]<-(profile[ii]/col_mean)#
		}#
		#col_min & max are used to adjust contrast when max contrast is called		#
		if (contrast != "max"){#
			col_min<-0#
			col_max<-1#
		}	else {#
			col_min<-min(profile[ii],na.rm=TRUE)	#
			col_max<-max(profile[ii],na.rm=TRUE)-col_min#
		}#
		#save flipped/reversed/contrast adjusted values into tmp_profile, as appropriate #
		if (cellProfilesFunctionEnvironment.env$fliplist[ii]==1) {#
			tmp_profile[c(real_rows:1),ii]<-(profile[c(1:real_rows),ii]-col_min)/(col_max)#
		} else {#
			tmp_profile[c(1:real_rows),ii]<-(profile[c(1:real_rows),ii]-col_min)/(col_max)#
		}#
		setTxtProgressBar(tick,ii)#
	}
tmp_profile
profile <- tmp_profile
#find maximum length of each column, and the number of real values in each column#
    #then order cells by measured cell length values#
	cellength <- {}#
	collength <- {}#
	for(i in 1:ncol){#
		cellength[i] <- max(dlength[i],na.rm=TRUE)#
	}#
	for(i in 1:ncol){#
		collength[i] <- nrow(na.omit(profile[i]))#
	}#
	setTxtProgressBar(tick,2*ncol)#
	collength <- order(cellength)#
	#setup the y values to stack each profile#
	plotheight <- {}#
	for(i in 1:ncol){#
		temp <- rep(i,nrow)#
		plotheight <- append(plotheight,temp)#
	}#
	setTxtProgressBar(tick,3*ncol)#
	#shifts cells to center (if center = TRUE)#
	if (position == "center"){#
		for(ii in 1:ncol){#
			col_adj <- (max(dlength[ii],na.rm=TRUE)+min(dlength[ii],na.rm=TRUE))/2#
			dlength[ii] <- dlength[ii]-col_adj#
		}#
	}#
	setTxtProgressBar(tick,(adj_tick-2)*ncol)#
	#apply order info from above#
	or_dlength <- melt(dlength[collength],id=NULL)#
	or_profile <- melt(profile[collength],id=NULL)#
	or_dtable <- cbind(or_dlength,plotheight,or_profile[2])#
	names(or_dtable) <- c("cell","x","y","intensity")#
	max <- max(or_dtable["intensity"],na.rm=TRUE)#
	min <- min(or_dtable["intensity"],na.rm=TRUE)#
	med <- median(as.matrix(or_dtable["intensity"]),na.rm=TRUE)#
	mid <- (max-min)/2+min#
	#simple code to breakdown the long data list into something human-readable#
	fodframe <- as.data.frame(or_profile[1:nrow,2])#
	colnames(fodframe) <- or_profile[1,1]#
	for(c in 2:ncol){#
		odframe <- as.data.frame(or_profile[(1:nrow)+(c-1)*nrow,2])#
		colnames(odframe) <- or_profile[(nrow*c),1]#
		fodframe <- cbind(fodframe,odframe)#
	}		#
	setTxtProgressBar(tick,(adj_tick-1)*ncol)#
	fodframe <- round(fodframe*1000)/1000#
	#prepared a list suitable for making x-y scatter plots (x-axis converted to proportion of cell length)#
	or_dlength <- dlength[collength]#
	for(i in 1:ncol){#
		or_dlength[i] <- rescale(or_dlength[i])#
	}#
	setTxtProgressBar(tick,(adj_tick)*ncol)#
	close(tick)#
	or_dlength <- melt(or_dlength,id=NULL)#
	por_dtable <- cbind(or_dlength,plotheight,or_profile[2])#
	names(por_dtable) <- c("cell","x","y","intensity")#
	#eliminate empty rows#
	or_dtable <- or_dtable[!is.na(or_dtable[4])==TRUE,c(1:4)]#
	#create contrast-truncated version#
	lim_or_dtable <- or_dtable	#
	lim_min <- colQuantiles(or_dtable["intensity"],cmin,na.rm=TRUE)#
	lim_max <- colQuantiles(or_dtable["intensity"],cmax,na.rm=TRUE)#
	cmin_count <- length(lim_or_dtable$intensity[lim_or_dtable$intensity<lim_min])#
	cmax_count <- length(lim_or_dtable$intensity[lim_or_dtable$intensity>lim_max])#
	lim_or_dtable[lim_or_dtable["intensity"]<lim_min,"intensity"] <- lim_min#
	lim_or_dtable[lim_or_dtable["intensity"]>lim_max,"intensity"] <- lim_max#
	len_count <- length(lim_or_dtable$intensity)#
	cat(len_count-cmin_count-cmax_count," profile points (",round(1000*(len_count-cmin_count-cmax_count)/len_count)/10,"%) fall in the range between the lower (",round(100*lim_min[[1]])/100,") and upper (",round(100*lim_max[[1]])/100,") contrast limits.\n",sep="")#
	profileResults <- list("or_dtable"=or_dtable, "lim_or_dtable"=lim_or_dtable, "data"=data, "form_dtable"=fodframe, "prop_dtable"=por_dtable, "ncol"=ncol, "nrow"=nrow, "max"=max, "min"=min, "med"=med, "mid"=mid, "maxlength"=maxlength)#
	tf <- proc.time()-t0#
	cat("Calculations on",ncol,"cells complete in",tf[["elapsed"]],"seconds.")
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
cellProfiles <- function(data=NULL,position="center",align="native",reverse=FALSE,contrast="native",range=c(0.02,0.98)){#
#============================#
#VERSION 2.4#
#USER GUIDE#
##
#Command line variables#
# Change the behavior of this function by defining these variables when calling it#
##
# 		eg: profileResults <- cellProfiles(data=dtable,align="orient",reverse=TRUE,contrast="normx")#
#		The above command would use the data "dtable" to produce a graph with:#
#			1) cells automatically aligned with the brightest sides [orient]#
#			2) on the *left* [reverse]#
#			3) while applying the normalize function (maximum ratio enforced via truncation) [normx]#
##
# data-handling options#
#  position = "center" or "left"#
#		[DEFAULT]->	center:	 plot with midcells aligned at point zero#
#					left:	plot with left side of cells aligned at zero#
##
#  align 	= "native", "orient", "random", "reuse"#
#		[DEFAULT]->	native:	profiles maintain original alignment#
#					orient:	automatically aligns the cell profiles so that the brightest points are on the same side#
#					random:	cells are randomly flipped#
#					reuse:	apply the last graphed orientations to the current graph#
##
#  reverse	= FALSE or TRUE#
#		[DEFAULT]->	FALSE:	no change in orientation#
#					TRUE:	plot profiles in reverse orientation (can be combined with, eg, align="reuse")#
#					#
# contrast adjustments for graphs	#
#  contrast = "native", "norm", "max"#
#		[DEFAULT]->	native:	profiles maintain original fluorescence intensities#
#					norm:  	divides each profile by its mean value#
#					max:	maximizes contrast #
##
#  range	= c(min,max)	This vector defines the lower and upper percentile boundaries of the color scale#
#		[DEFAULT]->	c(0.02,0.98)		treat these limits like changing the min/max displayed constrast in ImageJ etc#
##
#Exported variables#
# these variables are accessible from the script results. #
##
# 		eg, if you run: profileResults <- cellProfiles(data=dtable)#
# 		then the formatted final table is accessible at profileResults$form_dtable. #
# 		write the table to a new csv file using: #
#				write.csv(as.matrix(profileResults$form_dtable),file="cellprofiles wide format.csv")#
##
# or_dtable		long data table for ggplot#
# lim_or_dtable	long data table for ggplot, with values truncated as defined by the range setting#
# data			input data#
# form_dtable	wide-formatted table for human eyes#
# prop_dtable	long data table, where cell length is converted to fraction of cell length#
# ncol			number of cells measured#
# nrow			length of original data table#
# max			max fluorescence #
# min			min fluorescence#
# med			median fluorescence#
# mid			midpoint between min & max fluorescence#
# maxlength		longest cell length#
##
#END USER GUIDE#
#============================#
#
#============================#
#DEBUG tools#
##
#data <- raw_table#
#position <- "center"#
#align <- "native"#
#reverse <- FALSE#
#contrast <- "norm"#
#range <- c(0.02,0.98)#
##
#============================#
#
	t0<-proc.time()#
#
	#set up a few variables#
	if (local(exists("cellProfilesFunctionEnvironment.env"),envir=.GlobalEnv) == FALSE){local(cellProfilesFunctionEnvironment.env<-new.env(),envir=.GlobalEnv)}#
	if (!(is.vector(range)) || (!(length(range)==2)) || !(range[1]>=0 && range[2]<=1) || !(range[1]<range[2])){#
		cat("ERROR: Range must be between 0 and 1, in the format: c(min,max).");return(NULL)#
	}#
	if (position=="left"){adj_tick<-5} else {adj_tick<-6}#
	cmin <- range[1]#
	cmax <- range[2]#
	ncol <- ncol(data)/2#
	nrow <- nrow(data)#
	dlength <- data[seq(1,ncol*2,by=2)]#
	profile <- data[seq(2,ncol*2,by=2)]#
	maxlength <- ceiling(max(dlength,na.rm=TRUE))#
	wtmeanleft <- log((50:5)/5)/log(10)#
	wtmeanright <- log((5:50)/5)/log(10)#
	#sets up profile fliplist, or preserves prior orientations & disables inappropriate flags#
	if (align == "reuse"){#
		if ((local(exists("fliplist"), envir=cellProfilesFunctionEnvironment.env) != TRUE) || !(ncol == length(local(fliplist, envir=cellProfilesFunctionEnvironment.env)))){#
			cat("ERROR: Use of the align=\"reuse\" option requires prior evaluation of a dataset with the same number of cells... otherwise there is nothing to \"reuse\".")#
			return(NULL)#
		}#
		if (reverse == TRUE){#
			local(fliplist<-(fliplist-1)/-1, envir=cellProfilesFunctionEnvironment.env)#
		}#
	} else {#
		cellProfilesFunctionEnvironment.env$fliplist<-rep(1,ncol)#
		if (align == "random"){#
			cellProfilesFunctionEnvironment.env$fliplist[sample(ncol,ncol/2)]<-0#
		}#
	}#
	#perform contrast adjustments and aligns or randomizes data as set in the options above#
	cat("Calculating: \n ..")#
	tick <- txtProgressBar(min=1,max=ncol*adj_tick,style=3)#
	tmp_profile <- profile#
	for(ii in 1:ncol){#
		#for orient flag, find out if the top half of the column is brighter than the bottom half#
		#if not, then set fliplist[ii] to 1 so the column will be reversed#
		#DEBUG#
		# ii <- 1#
		real_rows <- nrow(na.omit(profile[ii]))#
		half_rows <- round(real_rows/2)#
		if ((align == "orient") && mean(profile[1:half_rows,ii]*approx(wtmeanleft,n=half_rows)$y) < mean(profile[(real_rows-half_rows+1):real_rows,ii]*approx(wtmeanright,n=half_rows)$y)){#
			cellProfilesFunctionEnvironment.env$fliplist[ii] <- 0#
		}#
		if ((reverse == TRUE) && (align != "reuse")){#
			cellProfilesFunctionEnvironment.env$fliplist[ii]<-(cellProfilesFunctionEnvironment.env$fliplist[ii]-1)/-1#
		}#
		#normalize profile data, as appropriate#
		if (contrast == "norm"){#
			col_mean<-mean(as.matrix(profile[ii]),na.rm=TRUE)#
			profile[ii]<-(profile[ii]/col_mean)#
		}#
		#col_min & max are used to adjust contrast when max contrast is called		#
		if (contrast != "max"){#
			col_min <- 0#
			col_max <- 1#
		}	else {#
			col_min <- min(profile[ii],na.rm=TRUE)	#
			col_max <- max(profile[ii],na.rm=TRUE)-col_min#
		}#
		#save flipped/reversed/contrast adjusted values into tmp_profile, as appropriate #
		if (cellProfilesFunctionEnvironment.env$fliplist[ii]==1) {#
			tmp_profile[c(real_rows:1),ii] <- (profile[c(1:real_rows),ii]-col_min)/(col_max)#
		} else {#
			tmp_profile[c(1:real_rows),ii] <- (profile[c(1:real_rows),ii]-col_min)/(col_max)#
		}#
		setTxtProgressBar(tick,ii)#
	}#
	profile <- tmp_profile#
    #find maximum length of each column, and the number of real values in each column#
    #then order cells by measured cell length values#
	cellength <- {}#
	collength <- {}#
	for(i in 1:ncol){#
		cellength[i] <- max(dlength[i],na.rm=TRUE)#
	}#
	for(i in 1:ncol){#
		collength[i] <- nrow(na.omit(profile[i]))#
	}#
	setTxtProgressBar(tick,2*ncol)#
	collength <- order(cellength)#
	#setup the y values to stack each profile#
	plotheight <- {}#
	for(i in 1:ncol){#
		temp <- rep(i,nrow)#
		plotheight <- append(plotheight,temp)#
	}#
	setTxtProgressBar(tick,3*ncol)#
	#shifts cells to center (if center = TRUE)#
	if (position == "center"){#
		for(ii in 1:ncol){#
			col_adj <- (max(dlength[ii],na.rm=TRUE)+min(dlength[ii],na.rm=TRUE))/2#
			dlength[ii] <- dlength[ii]-col_adj#
		}#
	}#
	setTxtProgressBar(tick,(adj_tick-2)*ncol)#
	#apply order info from above#
	or_dlength <- melt(dlength[collength],id=NULL)#
	or_profile <- melt(profile[collength],id=NULL)#
	or_dtable <- cbind(or_dlength,plotheight,or_profile[2])#
	names(or_dtable) <- c("cell","x","y","intensity")#
	max <- max(or_dtable["intensity"],na.rm=TRUE)#
	min <- min(or_dtable["intensity"],na.rm=TRUE)#
	med <- median(as.matrix(or_dtable["intensity"]),na.rm=TRUE)#
	mid <- (max-min)/2+min#
	#simple code to breakdown the long data list into something human-readable#
	fodframe <- as.data.frame(or_profile[1:nrow,2])#
	colnames(fodframe) <- or_profile[1,1]#
	for(c in 2:ncol){#
		odframe <- as.data.frame(or_profile[(1:nrow)+(c-1)*nrow,2])#
		colnames(odframe) <- or_profile[(nrow*c),1]#
		fodframe <- cbind(fodframe,odframe)#
	}		#
	setTxtProgressBar(tick,(adj_tick-1)*ncol)#
	fodframe <- round(fodframe*1000)/1000#
	#prepared a list suitable for making x-y scatter plots (x-axis converted to proportion of cell length)#
	or_dlength <- dlength[collength]#
	for(i in 1:ncol){#
		or_dlength[i] <- rescale(or_dlength[i])#
	}#
	setTxtProgressBar(tick,(adj_tick)*ncol)#
	close(tick)#
	or_dlength <- melt(or_dlength,id=NULL)#
	por_dtable <- cbind(or_dlength,plotheight,or_profile[2])#
	names(por_dtable) <- c("cell","x","y","intensity")#
	#eliminate empty rows#
	or_dtable <- or_dtable[!is.na(or_dtable[4])==TRUE,c(1:4)]#
	#create contrast-truncated version#
	lim_or_dtable <- or_dtable	#
	lim_min <- colQuantiles(or_dtable["intensity"],cmin,na.rm=TRUE)#
	lim_max <- colQuantiles(or_dtable["intensity"],cmax,na.rm=TRUE)#
	cmin_count <- length(lim_or_dtable$intensity[lim_or_dtable$intensity<lim_min])#
	cmax_count <- length(lim_or_dtable$intensity[lim_or_dtable$intensity>lim_max])#
	lim_or_dtable[lim_or_dtable["intensity"]<lim_min,"intensity"] <- lim_min#
	lim_or_dtable[lim_or_dtable["intensity"]>lim_max,"intensity"] <- lim_max#
	len_count <- length(lim_or_dtable$intensity)#
	cat(len_count-cmin_count-cmax_count," profile points (",round(1000*(len_count-cmin_count-cmax_count)/len_count)/10,"%) fall in the range between the lower (",round(100*lim_min[[1]])/100,") and upper (",round(100*lim_max[[1]])/100,") contrast limits.\n",sep="")#
	profileResults <- list("or_dtable"=or_dtable, "lim_or_dtable"=lim_or_dtable, "data"=data, "form_dtable"=fodframe, "prop_dtable"=por_dtable, "ncol"=ncol, "nrow"=nrow, "max"=max, "min"=min, "med"=med, "mid"=mid, "maxlength"=maxlength)#
	tf <- proc.time()-t0#
	cat("Calculations on",ncol,"cells complete in",tf[["elapsed"]],"seconds.")#
	return(profileResults)#
}#
#
cellProfileTruncate <- function(data=NULL,adjust){#
#============================#
#USER GUIDE#
##
# This function will remove [adjust] rows from the beginning and end of each cell#
# Use this function to correct when, for eg, wide selection lines collect too much dark background to accurately represent cell poles#
# Another solution to this problem would be to simply plot the graph background to a dark color#
# eg, add to the ggplot2 code: +theme(panel.background = element_rect(fill="#061542"))#
##
# adjust	= a positive integer. Will normally be 1-3 rows or so, depending on how you measured the data originally#
##
#END USER GUIDE#
#============================#
	#various sanity checks before performing the truncation#
	if (!(is.numeric(adjust) && floor(adjust)==adjust) || (adjust<0)){#
		cat("ERROR: adjustment value must be a positive integer.");return(NULL)#
	}#
	if (adjust == 0){#
		return(data)#
	} else if (adjust >= nrow(na.omit(data))/2){#
		cat("ERROR: cannot truncate more rows than exist. Must be",floor(nrow(na.omit(data))/2),"or fewer rows.");return(NULL)#
	} else if (2*adjust/nrow(na.omit(data)) > 0.25){#
		cat("WARNING: truncating ",round(100*2*adjust/nrow(na.omit(data))),"% of the shortest cell. This seems unwise.",sep="")#
	}#
	tmp_dtable<-matrix(NA,nrow(data),ncol(data))#
	#it is pretty easy to lop off the top of the table#
	data <- data[1+adjust:nrow(data),]#
	#however, taking off the bottom rows from each column (of different lengths) is rather more complicated#
	#below is an optimized form of a for loop that would copy, 2 columns at a time, all but the bottom [adjust] row(s)#
	for(i in seq(1,ncol(data),by=2)){#
		tmp_dtable[1:(nrow(as.matrix(data[!is.na(data[,i]),c(i)]))-adjust),c(i,i+1)] <- as.matrix(data[1:(nrow(as.matrix(data[!is.na(data[,i]),c(i)]))-adjust),c(i,i+1)])#
	}#
	return(as.data.frame(tmp_dtable))#
}#
#
library(ggplot2)  	#
library(reshape2)#
library(matrixStats)#
library(scales)#
library(grid)#
library(RColorBrewer)
library(ggplot2)		#
library(reshape2)#
library(matrixStats)#
library(scales)#
library(grid)#
library(RColorBrewer)
raw_table<-read.table("profiles.csv",header=FALSE,sep=",")
dtable<-cellProfileTruncate(data=raw_table,0)
#CENTERED -norm#
profileResults<-cellProfiles(data=dtable,contrast="norm")#
#
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
#NOT CENTERED -norm#
profileResults<-cellProfiles(data=dtable,position="left",contrast="norm")#
#
g2<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="cell length (um)",y="fraction of cell cycle",title="2- position=\"left\"")#
#
dev.new(width=4.86,height=3.4)#
g2
#================================================================#
#the following two graphs are general templates suitable for most data & purposes (in centered, and non-centered versions)#
#================================================================#
#
#CENTERED -norm#
profileResults<-cellProfiles(data=dtable,contrast="norm")#
#
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g#
#NOT CENTERED -norm#
profileResults<-cellProfiles(data=dtable,position="left",contrast="norm")#
#
g2<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="cell length (um)",y="fraction of cell cycle",title="2- position=\"left\"")#
#
dev.new(width=4.86,height=3.4)#
g2#
#================================================================#
#EXAMPLES OF GRAPHING OPTIONS #
#================================================================#
#The following graphs demonstrate the different graphing options available#
#Select from here to the bottom and execute to view them all#
raw_table<-read.table("profiles.csv",header=FALSE,sep=",")#
dtable<-cellProfileTruncate(data=raw_table,0)#
vplayout<-function(x,y) viewport(layout.pos.row=x,layout.pos.col=y)#
#
standard_theme	<-theme_bw(base_size=10)#
standard_labs	<-labs(x="distance from midcell (um)",y="fraction of cell cycle")#
standard_y		<-scale_y_continuous(expand=c(0,0),breaks=seq(0,1,0.25),trans="reverse")#
standard_fill	<-scale_fill_gradientn(colours=rev(brewer.pal(9,"YlGnBu")))#
standard_color	<-scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu")))#
standard_layer	<-function(x1,x2) layer(geom="tile",width=1.01*(x1-x2),size=0.25)#
#
dev.new(width=8,height=3.25)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(2,2, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Position Options", vp=viewport(layout.pos.row=1,layout.pos.col=1:2),gp=gpar(fontsize=16))#
print(g,vp=vplayout(2,1))#
print(g2,vp=vplayout(2,2))#
#
#================================================================#
#3- native#
#================================================================#
profileResults<-cellProfiles(data=dtable)#
#
pt3<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="3- contrast=\"native\"\n")#
#
#================================================================#
#4- max range=c(0,1)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="max",range=c(0,1))#
#
pt4<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + standard_labs+labs(title="4- contrast=\"max\",\n range=c(0,1)")#
#
#================================================================#
#5- norm range=c(0,1)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0,1))#
#
pt5<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="5- contrast=\"norm\",\n range=c(0,1)")#
#
#================================================================#
#6- norm range=c(0.005,0.995)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0.005,0.995))#
#
pt6<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="6- contrast=\"norm\",\n range=c(0.005,0.995)")#
#
#================================================================#
#7- norm range=c(0.02,0.98)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0.02,0.98))#
#
pt7<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="7- contrast=\"norm\",\n range=c(0.02,0.98)")#
#
#================================================================#
#8- norm range=c(0.05,0.95)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",range=c(0.05,0.95))#
#
pt8<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="8- contrast=\"norm\",\n range=c(0.05,0.95)")#
#
dev.new(width=12,height=6.4)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(3,3, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Contrast Options", vp=viewport(layout.pos.row=1,layout.pos.col=1:3),gp=gpar(fontsize=16))#
print(pt3,vp=vplayout(2,1))#
print(pt5,vp=vplayout(2,2))#
print(pt6,vp=vplayout(2,3))#
print(pt4,vp=vplayout(3,1))#
print(pt7,vp=vplayout(3,2))#
print(pt8,vp=vplayout(3,3))#
#================================================================#
#9- native#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="max")#
#
pt9<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="9- align=\"native\",\n contrast=\"max\"")#
#
#================================================================#
#10- orient#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="orient",contrast="max")#
#
pt10<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="10- align=\"orient\",\n contrast=\"max\"")#
#
#================================================================#
#11- random#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="random",contrast="max")#
#
pt11<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs+labs(title="11- align=\"random\",\n contrast=\"max\"")#
#
#================================================================#
#12- orient / reverse#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="orient",contrast="max",reverse=TRUE)#
#
pt12<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="12- align=\"orient\", reverse=TRUE, \ncontrast=\"max\"")#
#
#================================================================#
#13- reuse / reverse #1#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="reuse",contrast="max",reverse=TRUE)#
#
pt13<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="13- align=\"reuse\", reverse=TRUE, \ncontrast=\"max\"")#
#
#================================================================#
#14- reuse / reverse #2#
#================================================================#
profileResults<-cellProfiles(data=dtable,align="reuse",contrast="max",reverse=TRUE)#
#
pt14<-ggplot(profileResults$lim_or_dtable, aes(x=x, y=y/profileResults$ncol, fill=intensity, color=intensity)) + standard_layer(profileResults$data[2,1], profileResults$data[1,1]) + standard_theme + standard_y + standard_fill + standard_color + standard_labs + labs(title="14- align=\"reuse\", reverse=TRUE, \ncontrast=\"max\"")#
#
dev.new(width=12,height=6.4)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(3,3, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Alignment Options", vp=viewport(layout.pos.row=1,layout.pos.col=1:3),gp=gpar(fontsize=16))#
print(pt9,vp=vplayout(2,1))#
print(pt10,vp=vplayout(2,2))#
print(pt11,vp=vplayout(2,3))#
print(pt12,vp=vplayout(3,1))#
print(pt13,vp=vplayout(3,2))#
print(pt14,vp=vplayout(3,3))#
#
#================================================================#
#15- line plots of individual profiles \n#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",align="orient")#
#
pt15<-ggplot()+layer(data=profileResults$prop_dtable,mapping=aes(x=x,y=intensity,group=cell),geom="line",alpha=1/sqrt(profileResults$ncol))+theme_bw(base_size=10)+coord_cartesian(xlim=c(0,1))+labs(x="fraction of cell length",y="normalized intensity",title="15- line plots of individual profiles \n")#
#
#================================================================#
#16- line plots split between \nshort & long cells#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",align="orient")#
profileResults$prop_dtable[5]<-profileResults$prop_dtable["y"]/profileResults$ncol>0.5#
names(profileResults$prop_dtable)<- c("cell","x","y","intensity","half")#
#
min<-colQuantiles(profileResults$or_dtable["intensity"],0.05,na.rm=TRUE)#
max<-profileResults$max#
#
pt16<-ggplot() + layer(data=profileResults$prop_dtable, mapping=aes(x=x, y=intensity, group=cell, color=factor(half)), geom="line", alpha=2/sqrt(profileResults$ncol)) + theme_bw(base_size=10) + coord_cartesian(xlim=c(0,1)) + scale_color_brewer(palette="Set1") + scale_fill_brewer(palette="Set1") + theme(legend.position="none") + labs(x="fraction of cell length", y="normalized intensity", title="16- line plots split between short & long cells \n")#
#
#================================================================#
#17- line plots split between short\nmedium & long cells (simple mean & confidence)#
#================================================================#
profileResults<-cellProfiles(data=dtable,contrast="norm",align="orient")#
#
#interpolate profile results to align the data points#
nrow<-profileResults$nrow#
ncol<-profileResults$ncol#
interp_dtable<-matrix(data=NA,nrow=0,ncol=3)#
for (i in 1:ncol){#
	slice<-profileResults$prop_dtable[1:nrow+nrow*(i-1),]#
	len<-length(profileResults$form_dtable[!is.na(profileResults$form_dtable[i]),i])#
	interp<-approx(slice[c(2,4)],n=100)#
	interp_dtable<-rbind(interp_dtable,cbind(interp$x,interp$y,rep(i,100)))#
}#
interp_dtable<-as.data.frame(interp_dtable)#
#
#the next lines add a third colum that defines how to split the cells into categories#
#to swap to the method used for graph 16, comment out the next line, and uncomment the one after it#
interp_dtable[4]<-round(interp_dtable[3]/ncol*2)#
#interp_dtable[4]<-interp_dtable[3]/ncol>0.5#
names(interp_dtable)<-c("x","intensity","cell","half")#
#
min<-profileResults$min#
max<-profileResults$max#
#
pt17<-ggplot() + layer(data=interp_dtable, mapping=aes(x=x, y=intensity, group=cell, color=factor(half)), geom="line", alpha=3/sqrt(profileResults$ncol)) + stat_summary(data=interp_dtable, mapping=aes(x=x, y=intensity, group=factor(half)), fun.data="mean_cl_boot", geom="smooth", alpha=0.75, fill="black") + stat_summary(data=interp_dtable, mapping=aes(x=x, y=intensity, color=factor(half)), fun.y="mean", geom="line") + coord_cartesian(xlim=c(0,1)) + scale_color_brewer(palette="Set1") + scale_fill_brewer(palette="Set1") + theme_bw(base_size=10) + theme(legend.position="none") + labs(x="fraction of cell length", y="normalized intensity", title="17- line plots split between short\nmedium & long cells (simple mean & confidence)")#
#
#note: mean_cl_boot (based on smean.cl.boot from the Hmisc package) is "a very fast implementation of the basic nonparametric bootstrap for obtaining confidence limits for the population mean without assuming normality"#
#
#================================================================#
#18- gaussian kernel density \nplot of cell lengths#
#================================================================#
lengths<-{}#
lengths_temp<-raw_table[seq(1,ncol(raw_table),by=2)]#
for(i in 1:ncol(lengths_temp)){lengths[i]<-max(lengths_temp[i],na.rm=TRUE)}#
lengths<-as.data.frame(lengths)#
#
pt18<-ggplot() + layer(data=lengths, mapping=aes(x=lengths), geom="density") + theme_bw(base_size=10) + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0)) + labs(x="cell length (um)", y="probability density", title="18- gaussian kernel density \nplot of cell lengths")#
#
dev.new(width=8,height=6)#
grid.newpage()#
pushViewport(viewport(layout=grid.layout(3,2, heights = unit(c(0.25,3,3),"null"))))#
grid.text("Additional Graph Types and Examples", vp=viewport(layout.pos.row=1,layout.pos.col=1:2),gp=gpar(fontsize=16))#
print(pt15,vp=vplayout(2,1))#
print(pt16,vp=vplayout(2,2))#
cat("This one takes a moment to draw... be patient.")#
print(pt17,vp=vplayout(3,1))#
print(pt18,vp=vplayout(3,2))
#==================run this each new R session==================#
packages <- c("ggplot2", "reshape2", "hexbin", "quantreg", "matrixStats", "scales", "RColorBrewer", "mgcv", "Hmisc")#
#
#force install new packages#
#install.packages(list,dep=TRUE)#
#
#ipak from stevenworthington / GitHub#
# ipak function: install and load multiple R packages.#
# check to see if packages are installed. Install them if they are not, then load them into the R session.#
ipak <- function(pkg){#
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]#
    if (length(new.pkg)) #
        install.packages(new.pkg, dependencies = TRUE)#
    sapply(pkg, require, character.only = TRUE)#
}#
ipak(packages)
install.packages(packages,dep=TRUE)
ipak <- function(pkg){#
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]#
    if (length(new.pkg)) #
        install.packages(new.pkg, dependencies = TRUE)#
    sapply(pkg, require, character.only = TRUE)#
}#
ipak(packages)
#==================run this each new R session==================#
packages <- c("ggplot2", "reshape2", "hexbin", "quantreg", "matrixStats", "scales", "RColorBrewer", "grid")#
#
#force install new packages#
#install.packages(packages,dep=TRUE)#
#
#ipak from stevenworthington / GitHub#
# ipak function: install and load multiple R packages.#
# check to see if packages are installed. Install them if they are not, then load them into the R session.#
ipak <- function(pkg){#
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]#
    if (length(new.pkg)) #
        install.packages(new.pkg, dependencies = TRUE)#
    sapply(pkg, require, character.only = TRUE)#
}#
ipak(packages)
commands for changing to a specific directory & load data tables#
#assumes there is no header... use header=TRUE if there is one#
#setwd("")#
raw_table<-read.table("profiles.csv",header=FALSE,sep=",")#
#
#slightly truncate the poles to remove dark polar bands (artifact from width of profile line)#
dtable<-cellProfileTruncate(data=raw_table,5)#
#
#================================================================#
#the following two graphs are general templates suitable for most data & purposes (in centered, and non-centered versions)#
#================================================================#
#
#CENTERED -norm#
profileResults<-cellProfiles(data=dtable,contrast="norm")#
#
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
#commands for changing to a specific directory & load data tables#
#assumes there is no header... use header=TRUE if there is one#
#setwd("")#
raw_table<-read.table("profiles.csv",header=FALSE,sep=",")#
#
#slightly truncate the poles to remove dark polar bands (artifact from width of profile line)#
dtable<-cellProfileTruncate(data=raw_table,0)#
#
#================================================================#
#the following two graphs are general templates suitable for most data & purposes (in centered, and non-centered versions)#
#================================================================#
#
#CENTERED -norm#
profileResults<-cellProfiles(data=dtable,contrast="norm")#
#
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
#commands for changing to a specific directory & load data tables#
#assumes there is no header... use header=TRUE if there is one#
#setwd("")#
raw_table<-read.table("profiles.csv",header=FALSE,sep=",")#
#
#slightly truncate the poles to remove dark polar bands (artifact from width of profile line)#
dtable<-cellProfileTruncate(data=raw_table,0)#
#
#================================================================#
#the following two graphs are general templates suitable for most data & purposes (in centered, and non-centered versions)#
#================================================================#
#
#CENTERED -norm#
profileResults<-cellProfiles(data=dtable,contrast="norm")#
#
g<-ggplot() + layer(data=profileResults$lim_or_dtable, mapping=aes(x=x,y=y/profileResults$ncol, fill=intensity, color=intensity), geom="tile", width=1.01*(profileResults$data[2,1]-profileResults$data[1,1]), size=0.25) + scale_y_continuous(expand=c(0,0), breaks=seq(0,1,0.25), trans="reverse") + theme_bw() + scale_fill_gradientn(colours=rev(brewer.pal(9, "YlGnBu"))) + scale_color_gradientn(colours=rev(brewer.pal(9,"YlGnBu"))) + labs(x="distance from midcell (um)", y="fraction of cell cycle",title="1- position=\"center\"")#
#
dev.new(width=4.86,height=3.4)#
g
